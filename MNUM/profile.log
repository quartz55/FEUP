SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/cpp/clang_check.vim
Sourced 1 time
Total time:   0.022930
 Self time:   0.009539

count  total (s)   self (s)
                            "============================================================================
                            "File:        clang_check.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  Benjamin Bannier <bbannier at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    1              0.000028 if exists("g:loaded_syntastic_cpp_clang_check_checker")
                              finish
                            endif
    1              0.000014 let g:loaded_syntastic_cpp_clang_check_checker = 1
                            
    1              0.001518 runtime! syntax_checkers/c/*.vim
                            
    1   0.000798   0.000078 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'clang_check',
                                \ 'exec': 'clang-check',
                                \ 'redirect': 'c/clang_check'})
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/c/avrgcc.vim
Sourced 5 times
Total time:   0.001352
 Self time:   0.000673

count  total (s)   self (s)
                            "============================================================================
                            "File:        avrgcc.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  Karel <karelishere at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    5              0.000123 if exists('g:loaded_syntastic_c_avrgcc_checker')
    4              0.000027     finish
                            endif
    1              0.000041 let g:loaded_syntastic_c_avrgcc_checker = 1
                            
    1              0.000030 if !exists('g:syntastic_avrgcc_config_file')
    1              0.000010     let g:syntastic_avrgcc_config_file = '.syntastic_avrgcc_config'
    1              0.000002 endif
                            
    1              0.000031 let s:save_cpo = &cpo
    1              0.000031 set cpo&vim
                            
    1              0.000010 function! SyntaxCheckers_c_avrgcc_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args_before': syntastic#c#ReadConfig(g:syntastic_avrgcc_config_file),
                                    \ 'args_after': '-x c -fsyntax-only' })
                            
                                let errorformat =
                                    \ '%-G%f:%s:,' .
                                    \ '%-G%f:%l: %#error: %#(Each undeclared identifier is reported only%.%#,' .
                                    \ '%-G%f:%l: %#error: %#for each function it appears%.%#,' .
                                    \ '%-GIn file included%.%#,' .
                                    \ '%-G %#from %f:%l\,,' .
                                    \ '%f:%l:%c: %trror: %m,' .
                                    \ '%f:%l:%c: %tarning: %m,' .
                                    \ '%f:%l:%c: %m,' .
                                    \ '%f:%l: %trror: %m,' .
                                    \ '%f:%l: %tarning: %m,'.
                                    \ '%f:%l: %m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'postprocess': ['compressWhitespace'] })
                            endfunction
                            
    1   0.000720   0.000041 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'avrgcc',
                                \ 'exec': 'avr-gcc'})
                            
    1              0.000069 let &cpo = s:save_cpo
    1              0.000012 unlet s:save_cpo
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/c/checkpatch.vim
Sourced 5 times
Total time:   0.001583
 Self time:   0.000986

count  total (s)   self (s)
                            "============================================================================
                            "File:        checkpatch.vim
                            "Description: Syntax checking plugin for syntastic.vim using checkpatch.pl
                            "Maintainer:  Daniel Walker <dwalker at fifo99 dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    5              0.000117 if exists("g:loaded_syntastic_c_checkpatch_checker")
    4              0.000023     finish
                            endif
    1              0.000023 let g:loaded_syntastic_c_checkpatch_checker = 1
                            
    1              0.000051 let s:save_cpo = &cpo
    1              0.000063 set cpo&vim
                            
    1              0.000018 function! SyntaxCheckers_c_checkpatch_IsAvailable() dict
                                call syntastic#log#deprecationWarn('c_checker_checkpatch_location', 'c_checkpatch_exec')
                            
                                if !exists('g:syntastic_c_checkpatch_exec') && !executable(self.getExec())
                                    if executable('checkpatch')
                                        let g:syntastic_c_checkpatch_exec = 'checkpatch'
                                    elseif executable('./scripts/checkpatch.pl')
                                        let g:syntastic_c_checkpatch_exec = fnamemodify('./scripts/checkpatch.pl', ':p')
                                    elseif executable('./scripts/checkpatch')
                                        let g:syntastic_c_checkpatch_exec = fnamemodify('./scripts/checkpatch', ':p')
                                    endif
                                endif
                            
                                call self.log('exec =', self.getExec())
                            
                                return executable(self.getExec())
                            endfunction
                            
    1              0.000011 function! SyntaxCheckers_c_checkpatch_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'args_after': '--no-summary --no-tree --terse --file' })
                            
                                let errorformat =
                                    \ '%f:%l: %tARNING: %m,' .
                                    \ '%f:%l: %tRROR: %m'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'returns': [0, 1],
                                    \ 'subtype': 'Style' })
                            endfunction
                            
    1   0.000648   0.000051 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'checkpatch',
                                \ 'exec': 'checkpatch.pl'})
                            
    1              0.000043 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/c/clang_check.vim
Sourced 5 times
Total time:   0.001223
 Self time:   0.000636

count  total (s)   self (s)
                            "============================================================================
                            "File:        clang_check.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  Benjamin Bannier <bbannier at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    5              0.000112 if exists("g:loaded_syntastic_c_clang_check_checker")
    4              0.000022   finish
                            endif
    1              0.000017 let g:loaded_syntastic_c_clang_check_checker = 1
                            
    1              0.000019 if !exists('g:syntastic_clang_check_config_file')
    1              0.000016     let g:syntastic_clang_check_config_file = '.syntastic_clang_check_config'
    1              0.000004 endif
                            
    1              0.000034 let s:save_cpo = &cpo
    1              0.000037 set cpo&vim
                            
    1              0.000014 function! SyntaxCheckers_c_clang_check_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'post_args':
                                    \   '-- ' .
                                    \   syntastic#c#ReadConfig(g:syntastic_clang_check_config_file) . ' ' .
                                    \   '-fshow-column ' .
                                    \   '-fshow-source-location ' .
                                    \   '-fno-caret-diagnostics ' .
                                    \   '-fno-color-diagnostics ' .
                                    \   '-fdiagnostics-format=clang' })
                            
                                let errorformat =
                                    \ '%E%f:%l:%c: fatal error: %m,' .
                                    \ '%E%f:%l:%c: error: %m,' .
                                    \ '%W%f:%l:%c: warning: %m,' .
                                    \ '%-G%\m%\%%(LLVM ERROR:%\|No compilation database found%\)%\@!%.%#,' .
                                    \ '%E%m'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'defaults': {'bufnr': bufnr('')},
                                    \ 'returns': [0, 1] })
                            
                                call self.setWantSort(1)
                            
                                return loclist
                            endfunction
                            
    1   0.000629   0.000042 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'clang_check',
                                \ 'exec': 'clang-check'})
                            
    1              0.000061 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/c/clang_tidy.vim
Sourced 5 times
Total time:   0.001274
 Self time:   0.000667

count  total (s)   self (s)
                            "============================================================================
                            "File:        clang_tidy.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  Benjamin Bannier <bbannier at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    5              0.000114 if exists("g:loaded_syntastic_c_clang_tidy_checker")
    4              0.000021   finish
                            endif
    1              0.000016 let g:loaded_syntastic_c_clang_tidy_checker = 1
                            
    1              0.000019 if !exists('g:syntastic_clang_tidy_config_file')
    1              0.000018     let g:syntastic_clang_tidy_config_file = '.syntastic_clang_tidy_config'
    1              0.000006 endif
                            
    1              0.000035 let s:save_cpo = &cpo
    1              0.000037 set cpo&vim
                            
    1              0.000014 function! SyntaxCheckers_c_clang_tidy_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'post_args':
                                    \   '-- ' .
                                    \   syntastic#c#ReadConfig(g:syntastic_clang_tidy_config_file) . ' ' .
                                    \   '-fshow-column ' .
                                    \   '-fshow-source-location ' .
                                    \   '-fno-caret-diagnostics ' .
                                    \   '-fno-color-diagnostics ' .
                                    \   '-fdiagnostics-format=clang' })
                            
                                let errorformat =
                                    \ '%E%f:%l:%c: fatal error: %m,' .
                                    \ '%E%f:%l:%c: error: %m,' .
                                    \ '%W%f:%l:%c: warning: %m,' .
                                    \ '%-G%\m%\%%(LLVM ERROR:%\|No compilation database found%\)%\@!%.%#,' .
                                    \ '%E%m'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'defaults': {'bufnr': bufnr('')},
                                    \ 'returns': [0, 1] })
                            
                                call self.setWantSort(1)
                            
                                return loclist
                            endfunction
                            
    1   0.000656   0.000049 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'clang_tidy',
                                \ 'exec': 'clang-tidy'})
                            
    1              0.000044 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/c/cppcheck.vim
Sourced 5 times
Total time:   0.001236
 Self time:   0.000642

count  total (s)   self (s)
                            "============================================================================
                            "File:        cppcheck.vim
                            "Description: Syntax checking plugin for syntastic.vim using cppcheck.pl
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            "
                            " The setting 'g:syntastic_cppcheck_config_file' allows you to define a file
                            " that contains additional compiler arguments like include directories or
                            " CFLAGS. The file is expected to contain one option per line. If none is
                            " given the filename defaults to '.syntastic_cppcheck_config':
                            "
                            "   let g:syntastic_cppcheck_config_file = '.config'
                            
    5              0.000096 if exists("g:loaded_syntastic_c_cppcheck_checker")
    4              0.000022     finish
                            endif
    1              0.000008 let g:loaded_syntastic_c_cppcheck_checker = 1
                            
    1              0.000009 if !exists('g:syntastic_cppcheck_config_file')
    1              0.000028     let g:syntastic_cppcheck_config_file = '.syntastic_cppcheck_config'
    1              0.000006 endif
                            
    1              0.000037 let s:save_cpo = &cpo
    1              0.000040 set cpo&vim
                            
    1              0.000015 function! SyntaxCheckers_c_cppcheck_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args': syntastic#c#ReadConfig(g:syntastic_cppcheck_config_file),
                                    \ 'args_after': '-q --enable=style' })
                            
                                let errorformat =
                                    \ '[%f:%l]: (%trror) %m,' .
                                    \ '[%f:%l]: (%tarning) %m,' .
                                    \ '[%f:%l]: (%ttyle) %m,' .
                                    \ '[%f:%l]: (%terformance) %m,' .
                                    \ '[%f:%l]: (%tortability) %m,' .
                                    \ '[%f:%l]: (%tnformation) %m,' .
                                    \ '[%f:%l]: (%tnconclusive) %m,' .
                                    \ '%-G%.%#'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'preprocess': 'cppcheck',
                                    \ 'returns': [0] })
                            
                                for e in loclist
                                    if e['type'] =~? '\m^[SPI]'
                                        let e['type'] = 'w'
                                        let e['subtype'] = 'Style'
                                    endif
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000635   0.000041 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'cppcheck'})
                            
    1              0.000041 let &cpo = s:save_cpo
    1              0.000009 unlet s:save_cpo
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/c/gcc.vim
Sourced 5 times
Total time:   0.001225
 Self time:   0.000639

count  total (s)   self (s)
                            "============================================================================
                            "File:        c.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  Gregor Uhlenheuer <kongo2002 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    5              0.000104 if exists('g:loaded_syntastic_c_gcc_checker')
    4              0.000020     finish
                            endif
    1              0.000016 let g:loaded_syntastic_c_gcc_checker = 1
                            
    1              0.000017 if !exists('g:syntastic_c_compiler_options')
    1              0.000014     let g:syntastic_c_compiler_options = '-std=gnu99'
    1              0.000005 endif
                            
    1              0.000035 let s:save_cpo = &cpo
    1              0.000037 set cpo&vim
                            
    1              0.000014 function! SyntaxCheckers_c_gcc_IsAvailable() dict
                                if !exists('g:syntastic_c_compiler')
                                    let g:syntastic_c_compiler = executable(self.getExec()) ? self.getExec() : 'clang'
                                endif
                                call self.log('g:syntastic_c_compiler =', g:syntastic_c_compiler)
                                return executable(expand(g:syntastic_c_compiler))
                            endfunction
                            
    1              0.000011 function! SyntaxCheckers_c_gcc_GetLocList() dict
                                return syntastic#c#GetLocList('c', 'gcc', {
                                    \ 'errorformat':
                                    \     '%-G%f:%s:,' .
                                    \     '%-G%f:%l: %#error: %#(Each undeclared identifier is reported only%.%#,' .
                                    \     '%-G%f:%l: %#error: %#for each function it appears%.%#,' .
                                    \     '%-GIn file included%.%#,' .
                                    \     '%-G %#from %f:%l\,,' .
                                    \     '%f:%l:%c: %trror: %m,' .
                                    \     '%f:%l:%c: %tarning: %m,' .
                                    \     '%f:%l:%c: %m,' .
                                    \     '%f:%l: %trror: %m,' .
                                    \     '%f:%l: %tarning: %m,'.
                                    \     '%f:%l: %m',
                                    \ 'main_flags': '-x c -fsyntax-only',
                                    \ 'header_flags': '-x c',
                                    \ 'header_names': '\m\.h$' })
                            endfunction
                            
    1   0.000659   0.000073 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'gcc' })
                            
    1              0.000042 let &cpo = s:save_cpo
    1              0.000010 unlet s:save_cpo
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/c/make.vim
Sourced 5 times
Total time:   0.001173
 Self time:   0.000603

count  total (s)   self (s)
                            "============================================================================
                            "File:        make.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  Gregor Uhlenheuer <kongo2002 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    5              0.000087 if exists('g:loaded_syntastic_c_make_checker')
    4              0.000019     finish
                            endif
    1              0.000015 let g:loaded_syntastic_c_make_checker = 1
                            
    1              0.000054 let s:save_cpo = &cpo
    1              0.000037 set cpo&vim
                            
    1              0.000016 function! SyntaxCheckers_c_make_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'args': '-sk', 'fname': '' })
                            
                                let errorformat =
                                    \ '%-G%f:%s:,' .
                                    \ '%-G%f:%l: %#error: %#(Each undeclared identifier is reported only%.%#,' .
                                    \ '%-G%f:%l: %#error: %#for each function it appears%.%#,' .
                                    \ '%-GIn file included%.%#,' .
                                    \ '%-G %#from %f:%l\,,' .
                                    \ '%f:%l:%c: %trror: %m,' .
                                    \ '%f:%l:%c: %tarning: %m,' .
                                    \ '%f:%l:%c: %m,' .
                                    \ '%f:%l: %trror: %m,' .
                                    \ '%f:%l: %tarning: %m,'.
                                    \ '%f:%l: %m'
                            
                                if exists('g:syntastic_c_errorformat')
                                    let errorformat = g:syntastic_c_errorformat
                                endif
                            
                                " process makeprg
                                let errors = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat })
                            
                                " filter the processed errors if desired
                                if exists('g:syntastic_c_remove_include_errors') && g:syntastic_c_remove_include_errors != 0
                                    return filter(errors, 'has_key(v:val, "bufnr") && v:val["bufnr"] == ' . bufnr(''))
                                else
                                    return errors
                                endif
                            endfunction
                            
    1   0.000608   0.000038 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'make'})
                            
    1              0.000041 let &cpo = s:save_cpo
    1              0.000009 unlet s:save_cpo
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/c/oclint.vim
Sourced 5 times
Total time:   0.001260
 Self time:   0.000742

count  total (s)   self (s)
                            "============================================================================
                            "File:        oclint.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  "UnCO" Lin <undercooled aT lavabit com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            "
                            " The setting 'g:syntastic_oclint_config_file' allows you to define a file
                            " that contains additional compiler arguments like include directories or
                            " CFLAGS. The file is expected to contain one option per line. If none is
                            " given the filename defaults to '.syntastic_oclint_config':
                            "
                            "   let g:syntastic_oclint_config_file = '.config'
                            
    5              0.000103 if exists("g:loaded_syntastic_c_oclint_checker")
    4              0.000020     finish
                            endif
    1              0.000016 let g:loaded_syntastic_c_oclint_checker = 1
                            
    1              0.000017 if !exists('g:syntastic_oclint_config_file')
    1              0.000019     let g:syntastic_oclint_config_file = '.syntastic_oclint_config'
    1              0.000006 endif
                            
    1              0.000036 let s:save_cpo = &cpo
    1              0.000038 set cpo&vim
                            
    1              0.000015 function! SyntaxCheckers_c_oclint_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'post_args': '-- -c ' . syntastic#c#ReadConfig(g:syntastic_oclint_config_file) })
                            
                                let errorformat =
                                    \ '%E%f:%l:%c: fatal error: %m,' .
                                    \ '%E%f:%l:%c: error: %m,' .
                                    \ '%W%f:%l:%c: warning: %m,' .
                                    \ '%E%f:%l:%c: %m,' .
                                    \ '%-G%.%#'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype': 'Style',
                                    \ 'postprocess': ['compressWhitespace'],
                                    \ 'returns': [0, 3, 5] })
                            
                                for e in loclist
                                    if e['text'] =~# '\v P3( |$)'
                                        let e['type'] = 'W'
                                    endif
                            
                                    let e['text'] = substitute(e['text'], '\m\C P[1-3]$', '', '')
                                    let e['text'] = substitute(e['text'], '\m\C P[1-3] ', ': ', '')
                                endfor
                            
                                call self.setWantSort(1)
                            
                                return loclist
                            endfunction
                            
    1   0.000558   0.000040 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'oclint'})
                            
    1              0.000042 let &cpo = s:save_cpo
    1              0.000011 unlet s:save_cpo
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/c/pc_lint.vim
Sourced 5 times
Total time:   0.001247
 Self time:   0.000631

count  total (s)   self (s)
                            "============================================================================
                            "File:        pc_lint.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  Steve Bragg <steve at empresseffects dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    5              0.000105 if exists("g:loaded_syntastic_c_pc_lint_checker")
    4              0.000020     finish
                            endif
    1              0.000008 let g:loaded_syntastic_c_pc_lint_checker = 1
                            
    1              0.000027 let s:save_cpo = &cpo
    1              0.000029 set cpo&vim
                            
    1              0.000028 if !exists('g:syntastic_pc_lint_config_file')
    1              0.000008     let g:syntastic_pc_lint_config_file = 'options.lnt'
    1              0.000003 endif
                            
    1              0.000008 function! SyntaxCheckers_c_pc_lint_GetLocList() dict
                                let config = findfile(g:syntastic_pc_lint_config_file, '.;')
                                call self.log('config =', config)
                            
                                " -hFs1         - show filename, add space after messages, try to make message 1 line
                                " -width(0,0)   - make sure there are no line breaks
                                " -t            - set tab size
                                " -v            - turn off verbosity
                                let makeprg = self.makeprgBuild({
                                    \ 'args': (filereadable(config) ? syntastic#util#shescape(fnamemodify(config, ':p')) : ''),
                                    \ 'args_after': ['-hFs1', '-width(0,0)', '-t' . &tabstop, '-format=%f:%l:%C:%t:%n:%m'] })
                            
                                let errorformat =
                                    \ '%E%f:%l:%v:Error:%n:%m,' .
                                    \ '%W%f:%l:%v:Warning:%n:%m,' .
                                    \ '%I%f:%l:%v:Info:%n:%m,' .
                                    \ '%-G%.%#'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'postprocess': ['cygwinRemoveCR'] })
                            
                                for e in loclist
                                    if e['type'] ==? 'I'
                                        let e['type'] = 'W'
                                        let e['subtype'] = 'Style'
                                    endif
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000667   0.000051 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'pc_lint',
                                \ 'exec': 'lint-nt'})
                            
    1              0.000049 let &cpo = s:save_cpo
    1              0.000012 unlet s:save_cpo
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/c/sparse.vim
Sourced 5 times
Total time:   0.001382
 Self time:   0.000758

count  total (s)   self (s)
                            "============================================================================
                            "File:        sparse.vim
                            "Description: Syntax checking plugin for syntastic.vim using sparse.pl
                            "Maintainer:  Daniel Walker <dwalker at fifo99 dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            "
                            " The setting 'g:syntastic_sparse_config_file' allows you to define a file
                            " that contains additional compiler arguments like include directories or
                            " CFLAGS. The file is expected to contain one option per line. If none is
                            " given the filename defaults to '.syntastic_sparse_config':
                            "
                            "   let g:syntastic_sparse_config_file = '.config'
                            
    5              0.000110 if exists("g:loaded_syntastic_c_sparse_checker")
    4              0.000020     finish
                            endif
    1              0.000018 let g:loaded_syntastic_c_sparse_checker = 1
                            
    1              0.000018 if !exists('g:syntastic_sparse_config_file')
    1              0.000018     let g:syntastic_sparse_config_file = '.syntastic_sparse_config'
    1              0.000006 endif
                            
    1              0.000038 let s:save_cpo = &cpo
    1              0.000040 set cpo&vim
                            
    1              0.000015 function! SyntaxCheckers_c_sparse_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args': syntastic#c#ReadConfig(g:syntastic_sparse_config_file),
                                    \ 'args_after': '-ftabstop=' . &ts })
                            
                                let errorformat = '%f:%l:%v: %trror: %m,%f:%l:%v: %tarning: %m,'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'defaults': {'bufnr': bufnr("")},
                                    \ 'returns': [0] })
                                return loclist
                            endfunction
                            
    1   0.000666   0.000042 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'sparse'})
                            
    1              0.000077 let &cpo = s:save_cpo
    1              0.000012 unlet s:save_cpo
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/c/splint.vim
Sourced 5 times
Total time:   0.001250
 Self time:   0.000633

count  total (s)   self (s)
                            "============================================================================
                            "File:        splint.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            "
                            " The setting 'g:syntastic_splint_config_file' allows you to define a file
                            " that contains additional compiler arguments like include directories or
                            " CFLAGS. The file is expected to contain one option per line. If none is
                            " given the filename defaults to '.syntastic_splint_config':
                            "
                            "   let g:syntastic_splint_config_file = '.config'
                            
    5              0.000084 if exists("g:loaded_syntastic_c_splint_checker")
    4              0.000015     finish
                            endif
    1              0.000016 let g:loaded_syntastic_c_splint_checker = 1
                            
    1              0.000019 if !exists('g:syntastic_splint_config_file')
    1              0.000017     let g:syntastic_splint_config_file = '.syntastic_splint_config'
    1              0.000005 endif
                            
    1              0.000035 let s:save_cpo = &cpo
    1              0.000039 set cpo&vim
                            
    1              0.000015 function! SyntaxCheckers_c_splint_GetLocList() dict
                                let makeprg = self.makeprgBuild({
                                    \ 'args': syntastic#c#ReadConfig(g:syntastic_splint_config_file),
                                    \ 'args_after': '-showfunc -hints +quiet' })
                            
                                let errorformat =
                                    \ '%-G%f:%l:%v: %[%#]%[%#]%[%#] Internal Bug %.%#,' .
                                    \ '%-G%f(%l\,%v): %[%#]%[%#]%[%#] Internal Bug %.%#,' .
                                    \ '%W%f:%l:%v: %m,' .
                                    \ '%W%f(%l\,%v): %m,' .
                                    \ '%W%f:%l: %m,' .
                                    \ '%W%f(%l): %m,' .
                                    \ '%-C %\+In file included from %.%#,' .
                                    \ '%-C %\+from %.%#,' .
                                    \ '%+C %.%#'
                            
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype': 'Style',
                                    \ 'postprocess': ['compressWhitespace'],
                                    \ 'defaults': {'type': 'W'} })
                            endfunction
                            
    1   0.000656   0.000039 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'c',
                                \ 'name': 'splint'})
                            
    1              0.000041 let &cpo = s:save_cpo
    1              0.000011 unlet s:save_cpo
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/cpp/clang_tidy.vim
Sourced 1 time
Total time:   0.011933
 Self time:   0.010312

count  total (s)   self (s)
                            "============================================================================
                            "File:        clang_tidy.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  Benjamin Bannier <bbannier at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            
    1              0.000029 if exists("g:loaded_syntastic_cpp_clang_tidy_checker")
                              finish
                            endif
    1              0.000019 let g:loaded_syntastic_cpp_clang_tidy_checker = 1
                            
    1              0.002521 runtime! syntax_checkers/c/*.vim
                            
    1   0.000807   0.000075 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'clang_tidy',
                                \ 'exec': 'clang-tidy',
                                \ 'redirect': 'c/clang_tidy'})
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/cpp/cppcheck.vim
Sourced 1 time
Total time:   0.009576
 Self time:   0.008292

count  total (s)   self (s)
                            "============================================================================
                            "File:        cppcheck.vim
                            "Description: Syntax checking plugin for syntastic.vim using cppcheck.pl
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            "
                            " The setting 'g:syntastic_cppcheck_config_file' allows you to define a file
                            " that contains additional compiler arguments like include directories or
                            " CFLAGS. The file is expected to contain one option per line. If none is
                            " given the filename defaults to '.syntastic_cppcheck_config':
                            "
                            "   let g:syntastic_cppcheck_config_file = '.config'
                            
    1              0.000028 if exists("g:loaded_syntastic_cpp_cppcheck_checker")
                                finish
                            endif
    1              0.000018 let g:loaded_syntastic_cpp_cppcheck_checker = 1
                            
    1              0.002345 runtime! syntax_checkers/c/*.vim
                            
    1   0.000477   0.000043 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'cppcheck',
                                \ 'redirect': 'c/cppcheck'})
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/cpp/cpplint.vim
Sourced 1 time
Total time:   0.000654
 Self time:   0.000294

count  total (s)   self (s)
                            "============================================================================
                            "File:        cpplint.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  LCD 47 <lcd047 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            "
                            " For details about cpplint see:
                            "    https://code.google.com/p/google-styleguide/
                            "
                            " Checker options:
                            "
                            " - g:syntastic_cpp_cpplint_thres (integer; default: 5)
                            "   error threshold: policy violations with a severity above this
                            "   value are highlighted as errors, the others are warnings
                            "
                            " - g:syntastic_cpp_cpplint_args (string; default: '--verbose=3')
                            "   command line options to pass to cpplint
                            
    1              0.000019 if exists("g:loaded_syntastic_cpp_cpplint_checker")
                                finish
                            endif
    1              0.000012 let g:loaded_syntastic_cpp_cpplint_checker = 1
                            
    1              0.000010 if !exists('g:syntastic_cpp_cpplint_thres')
    1              0.000008     let g:syntastic_cpp_cpplint_thres = 5
    1              0.000003 endif
                            
    1              0.000028 let s:save_cpo = &cpo
    1              0.000030 set cpo&vim
                            
    1              0.000011 function! SyntaxCheckers_cpp_cpplint_GetLocList() dict
                                let makeprg = self.makeprgBuild({ 'args': '--verbose=3' })
                            
                                let errorformat = '%A%f:%l:  %m [%t],%-G%.%#'
                            
                                let loclist = SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'subtype': 'Style',
                                    \ 'returns': [0, 1] })
                            
                                " change error types according to the prescribed threshold
                                for e in loclist
                                    let e['type'] = e['type'] < g:syntastic_cpp_cpplint_thres ? 'W' : 'E'
                                endfor
                            
                                return loclist
                            endfunction
                            
    1   0.000388   0.000028 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'cpplint',
                                \ 'exec': 'cpplint.py'})
                            
    1              0.000028 let &cpo = s:save_cpo
    1              0.000007 unlet s:save_cpo
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/cpp/gcc.vim
Sourced 1 time
Total time:   0.000663
 Self time:   0.000283

count  total (s)   self (s)
                            "============================================================================
                            "File:        cpp.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  Gregor Uhlenheuer <kongo2002 at gmail dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000017 if exists('g:loaded_syntastic_cpp_gcc_checker')
                                finish
                            endif
    1              0.000011 let g:loaded_syntastic_cpp_gcc_checker = 1
                            
    1              0.000011 if !exists('g:syntastic_cpp_compiler_options')
    1              0.000010     let g:syntastic_cpp_compiler_options = ''
    1              0.000003 endif
                            
    1              0.000023 let s:save_cpo = &cpo
    1              0.000041 set cpo&vim
                            
    1              0.000010 function! SyntaxCheckers_cpp_gcc_IsAvailable() dict
                                if !exists('g:syntastic_cpp_compiler')
                                    let g:syntastic_cpp_compiler = executable(self.getExec()) ? self.getExec() : 'clang++'
                                endif
                                call self.log('g:syntastic_cpp_compiler =', g:syntastic_cpp_compiler)
                                return executable(expand(g:syntastic_cpp_compiler))
                            endfunction
                            
    1              0.000007 function! SyntaxCheckers_cpp_gcc_GetLocList() dict
                                return syntastic#c#GetLocList('cpp', 'gcc', {
                                    \ 'errorformat':
                                    \     '%-G%f:%s:,' .
                                    \     '%f:%l:%c: %trror: %m,' .
                                    \     '%f:%l:%c: %tarning: %m,' .
                                    \     '%f:%l:%c: %m,'.
                                    \     '%f:%l: %trror: %m,'.
                                    \     '%f:%l: %tarning: %m,'.
                                    \     '%f:%l: %m',
                                    \ 'main_flags': '-x c++ -fsyntax-only',
                                    \ 'header_flags': '-x c++',
                                    \ 'header_names': '\m\.\(h\|hpp\|hh\)$' })
                            endfunction
                            
    1   0.000406   0.000026 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'gcc',
                                \ 'exec': 'g++' })
                            
    1              0.000027 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/cpp/oclint.vim
Sourced 1 time
Total time:   0.007282
 Self time:   0.006339

count  total (s)   self (s)
                            "============================================================================
                            "File:        oclint.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  "UnCO" Lin <undercooled aT lavabit com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "============================================================================
                            "
                            " The setting 'g:syntastic_oclint_config_file' allows you to define a file
                            " that contains additional compiler arguments like include directories or
                            " CFLAGS. The file is expected to contain one option per line. If none is
                            " given the filename defaults to '.syntastic_oclint_config':
                            "
                            "   let g:syntastic_oclint_config_file = '.config'
                            
    1              0.000018 if exists("g:loaded_syntastic_cpp_oclint_checker")
                                finish
                            endif
    1              0.000011 let g:loaded_syntastic_cpp_oclint_checker = 1
                            
    1              0.001577 runtime! syntax_checkers/c/*.vim
                            
    1   0.000435   0.000035 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'oclint',
                                \ 'redirect': 'c/oclint'})
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/syntax_checkers/cpp/pc_lint.vim
Sourced 1 time
Total time:   0.007541
 Self time:   0.006608

count  total (s)   self (s)
                            "============================================================================
                            "File:        pc_lint.vim
                            "Description: Syntax checking plugin for syntastic.vim
                            "Maintainer:  Steve Bragg <steve at empresseffects dot com>
                            "License:     This program is free software. It comes without any warranty,
                            "             to the extent permitted by applicable law. You can redistribute
                            "             it and/or modify it under the terms of the Do What The Fuck You
                            "             Want To Public License, Version 2, as published by Sam Hocevar.
                            "             See http://sam.zoy.org/wtfpl/COPYING for more details.
                            "
                            "============================================================================
                            
    1              0.000018 if exists("g:loaded_syntastic_cpp_pc_lint_checker")
                                finish
                            endif
    1              0.000103 let g:loaded_syntastic_cpp_pc_lint_checker = 1
                            
    1              0.001557 runtime! syntax_checkers/c/*.vim
                            
    1   0.000438   0.000037 call g:SyntasticRegistry.CreateAndRegisterChecker({
                                \ 'filetype': 'cpp',
                                \ 'name': 'pc_lint',
                                \ 'exec': 'lint-nt',
                                \ 'redirect': 'c/pc_lint'})
                            
                            " vim: set et sts=4 sw=4:

SCRIPT  /home/john/.spf13-vim-3/.vim/bundle/syntastic/autoload/syntastic/c.vim
Sourced 1 time
Total time:   0.002180
 Self time:   0.001168

count  total (s)   self (s)
                            if exists("g:loaded_syntastic_c_autoload") || !exists("g:loaded_syntastic_plugin")
                                finish
                            endif
    1              0.000065 let g:loaded_syntastic_c_autoload = 1
                            
    1              0.000042 let s:save_cpo = &cpo
    1              0.000043 set cpo&vim
                            
                            " Public functions {{{1
                            
                            " convenience function to determine the 'null device' parameter
                            " based on the current operating system
    1              0.000014 function! syntastic#c#NullOutput() " {{{2
                                let known_os = has('unix') || has('mac') || syntastic#util#isRunningWindows()
                                return known_os ? '-o ' . syntastic#util#DevNull() : ''
                            endfunction " }}}2
                            
                            " read additional compiler flags from the given configuration file
                            " the file format and its parsing mechanism is inspired by clang_complete
    1              0.000011 function! syntastic#c#ReadConfig(file) " {{{2
                                " search in the current file's directory upwards
                                let config = findfile(a:file, '.;')
                                if config == '' || !filereadable(config)
                                    return ''
                                endif
                            
                                " convert filename into absolute path
                                let filepath = fnamemodify(config, ':p:h')
                            
                                " try to read config file
                                try
                                    let lines = readfile(config)
                                catch /\m^Vim\%((\a\+)\)\=:E48[45]/
                                    return ''
                                endtry
                            
                                " filter out empty lines and comments
                                call filter(lines, 'v:val !~ ''\v^(\s*#|$)''')
                            
                                " remove leading and trailing spaces
                                call map(lines, 'substitute(v:val, ''\m^\s\+'', "", "")')
                                call map(lines, 'substitute(v:val, ''\m\s\+$'', "", "")')
                            
                                let parameters = []
                                for line in lines
                                    let matches = matchstr(line, '\m\C^\s*-I\s*\zs.\+')
                                    if matches != ''
                                        " this one looks like an absolute path
                                        if match(matches, '\m^\%(/\|\a:\)') != -1
                                            call add(parameters, '-I' . matches)
                                        else
                                            call add(parameters, '-I' . filepath . syntastic#util#Slash() . matches)
                                        endif
                                    else
                                        call add(parameters, line)
                                    endif
                                endfor
                            
                                return join(map(parameters, 'syntastic#util#shescape(v:val)'))
                            endfunction " }}}2
                            
                            " GetLocList() for C-like compilers
    1              0.000012 function! syntastic#c#GetLocList(filetype, subchecker, options) " {{{2
                                try
                                    let flags = s:_getCflags(a:filetype, a:subchecker, a:options)
                                catch /\m\C^Syntastic: skip checks$/
                                    return []
                                endtry
                            
                                let makeprg = syntastic#util#shexpand(g:syntastic_{a:filetype}_compiler) .
                                    \ ' ' . flags . ' ' . syntastic#util#shexpand('%')
                            
                                let errorformat = s:_getCheckerVar('g', a:filetype, a:subchecker, 'errorformat', a:options['errorformat'])
                            
                                let postprocess = s:_getCheckerVar('g', a:filetype, a:subchecker, 'remove_include_errors', 0) ?
                                    \ ['filterForeignErrors'] : []
                            
                                " process makeprg
                                return SyntasticMake({
                                    \ 'makeprg': makeprg,
                                    \ 'errorformat': errorformat,
                                    \ 'postprocess': postprocess })
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " Private functions {{{1
                            
                            " initialize c/cpp syntax checker handlers
    1              0.000009 function! s:_init() " {{{2
                                let s:handlers = []
                                let s:cflags = {}
                            
                                call s:_regHandler('\m\<cairo',       's:_check_pkg', ['cairo', 'cairo'])
                                call s:_regHandler('\m\<freetype',    's:_check_pkg', ['freetype', 'freetype2', 'freetype'])
                                call s:_regHandler('\m\<glade',       's:_check_pkg', ['glade', 'libglade-2.0', 'libglade'])
                                call s:_regHandler('\m\<glib',        's:_check_pkg', ['glib', 'glib-2.0', 'glib'])
                                call s:_regHandler('\m\<gtk',         's:_check_pkg', ['gtk', 'gtk+-2.0', 'gtk+', 'glib-2.0', 'glib'])
                                call s:_regHandler('\m\<libsoup',     's:_check_pkg', ['libsoup', 'libsoup-2.4', 'libsoup-2.2'])
                                call s:_regHandler('\m\<libxml',      's:_check_pkg', ['libxml', 'libxml-2.0', 'libxml'])
                                call s:_regHandler('\m\<pango',       's:_check_pkg', ['pango', 'pango'])
                                call s:_regHandler('\m\<SDL',         's:_check_pkg', ['sdl', 'sdl'])
                                call s:_regHandler('\m\<opengl',      's:_check_pkg', ['opengl', 'gl'])
                                call s:_regHandler('\m\<webkit',      's:_check_pkg', ['webkit', 'webkit-1.0'])
                            
                                call s:_regHandler('\m\<php\.h\>',    's:_check_php',    [])
                                call s:_regHandler('\m\<Python\.h\>', 's:_check_python', [])
                                call s:_regHandler('\m\<ruby',        's:_check_ruby',   [])
                            endfunction " }}}2
                            
                            " return a handler dictionary object
    1              0.000010 function! s:_regHandler(regex, function, args) " {{{2
                                let handler = {}
                                let handler["regex"] = a:regex
                                let handler["func"] = function(a:function)
                                let handler["args"] = a:args
                                call add(s:handlers, handler)
                            endfunction " }}}2
                            
                            " resolve checker-related user variables
    1              0.000011 function! s:_getCheckerVar(scope, filetype, subchecker, name, default) " {{{2
                                let prefix = a:scope . ':' . 'syntastic_'
                                if exists(prefix . a:filetype . '_' . a:subchecker . '_' . a:name)
                                    return {a:scope}:syntastic_{a:filetype}_{a:subchecker}_{a:name}
                                elseif exists(prefix . a:filetype . '_' . a:name)
                                    return {a:scope}:syntastic_{a:filetype}_{a:name}
                                else
                                    return a:default
                                endif
                            endfunction " }}}2
                            
                            " resolve user CFLAGS
    1              0.000010 function! s:_getCflags(ft, ck, opts) " {{{2
                                " determine whether to parse header files as well
                                if has_key(a:opts, 'header_names') && expand('%') =~? a:opts['header_names']
                                    if s:_getCheckerVar('g', a:ft, a:ck, 'check_header', 0)
                                        let flags = get(a:opts, 'header_flags', '') . ' -c ' . syntastic#c#NullOutput()
                                    else
                                        " checking headers when check_header is unset: bail out
                                        throw 'Syntastic: skip checks'
                                    endif
                                else
                                    let flags = get(a:opts, 'main_flags', '')
                                endif
                            
                                let flags .= ' ' . s:_getCheckerVar('g', a:ft, a:ck, 'compiler_options', '') . ' ' . s:_getIncludeDirs(a:ft)
                            
                                " check if the user manually set some cflags
                                let b_cflags = s:_getCheckerVar('b', a:ft, a:ck, 'cflags', '')
                                if b_cflags == ''
                                    " check whether to search for include files at all
                                    if !s:_getCheckerVar('g', a:ft, a:ck, 'no_include_search', 0)
                                        if a:ft ==# 'c' || a:ft ==# 'cpp'
                                            " refresh the include file search if desired
                                            if s:_getCheckerVar('g', a:ft, a:ck, 'auto_refresh_includes', 0)
                                                let flags .= ' ' . s:_searchHeaders()
                                            else
                                                " search for header includes if not cached already
                                                if !exists('b:syntastic_' . a:ft . '_includes')
                                                    let b:syntastic_{a:ft}_includes = s:_searchHeaders()
                                                endif
                                                let flags .= ' ' . b:syntastic_{a:ft}_includes
                                            endif
                                        endif
                                    endif
                                else
                                    " user-defined cflags
                                    let flags .= ' ' . b_cflags
                                endif
                            
                                " add optional config file parameters
                                let config_file = s:_getCheckerVar('g', a:ft, a:ck, 'config_file', '.syntastic_' . a:ft . '_config')
                                let flags .= ' ' . syntastic#c#ReadConfig(config_file)
                            
                                return flags
                            endfunction " }}}2
                            
                            " get the gcc include directory argument depending on the default
                            " includes and the optional user-defined 'g:syntastic_c_include_dirs'
    1              0.000008 function! s:_getIncludeDirs(filetype) " {{{2
                                let include_dirs = []
                            
                                if a:filetype =~# '\v^%(c|cpp|objc|objcpp)$' &&
                                            \ (!exists('g:syntastic_'.a:filetype.'_no_default_include_dirs') ||
                                            \ !g:syntastic_{a:filetype}_no_default_include_dirs)
                                    let include_dirs = copy(s:default_includes)
                                endif
                            
                                if exists('g:syntastic_'.a:filetype.'_include_dirs')
                                    call extend(include_dirs, g:syntastic_{a:filetype}_include_dirs)
                                endif
                            
                                return join(map(syntastic#util#unique(include_dirs), 'syntastic#util#shescape("-I" . v:val)'))
                            endfunction " }}}2
                            
                            " search the first 100 lines for include statements that are
                            " given in the handlers dictionary
    1              0.000006 function! s:_searchHeaders() " {{{2
                                let includes = ''
                                let files = []
                                let found = []
                                let lines = filter(getline(1, 100), 'v:val =~# ''\m^\s*#\s*include''')
                            
                                " search current buffer
                                for line in lines
                                    let file = matchstr(line, '\m"\zs\S\+\ze"')
                                    if file != ''
                                        call add(files, file)
                                        continue
                                    endif
                            
                                    for handler in s:handlers
                                        if line =~# handler["regex"]
                                            let includes .= call(handler["func"], handler["args"])
                                            call add(found, handler["regex"])
                                            break
                                        endif
                                    endfor
                                endfor
                            
                                " search included headers
                                for hfile in files
                                    if hfile != ''
                                        let filename = expand('%:p:h') . syntastic#util#Slash() . hfile
                            
                                        try
                                            let lines = readfile(filename, '', 100)
                                        catch /\m^Vim\%((\a\+)\)\=:E484/
                                            continue
                                        endtry
                            
                                        call filter(lines, 'v:val =~# ''\m^\s*#\s*include''')
                            
                                        for handler in s:handlers
                                            if index(found, handler["regex"]) != -1
                                                continue
                                            endif
                            
                                            for line in lines
                                                if line =~# handler["regex"]
                                                    let includes .= call(handler["func"], handler["args"])
                                                    call add(found, handler["regex"])
                                                    break
                                                endif
                                            endfor
                                        endfor
                                    endif
                                endfor
                            
                                return includes
                            endfunction " }}}2
                            
                            " try to find library with 'pkg-config'
                            " search possible libraries from first to last given
                            " argument until one is found
    1              0.000008 function! s:_check_pkg(name, ...) " {{{2
                                if executable('pkg-config')
                                    if !has_key(s:cflags, a:name)
                                        for pkg in a:000
                                            let pkg_flags = system('pkg-config --cflags ' . pkg)
                                            " since we cannot necessarily trust the pkg-config exit code
                                            " we have to check for an error output as well
                                            if v:shell_error == 0 && pkg_flags !~? 'not found'
                                                let pkg_flags = ' ' . substitute(pkg_flags, "\n", '', '')
                                                let s:cflags[a:name] = pkg_flags
                                                return pkg_flags
                                            endif
                                        endfor
                                    else
                                        return s:cflags[a:name]
                                    endif
                                endif
                                return ''
                            endfunction " }}}2
                            
                            " try to find PHP includes with 'php-config'
    1              0.000006 function! s:_check_php() " {{{2
                                if executable('php-config')
                                    if !has_key(s:cflags, 'php')
                                        let s:cflags['php'] = system('php-config --includes')
                                        let s:cflags['php'] = ' ' . substitute(s:cflags['php'], "\n", '', '')
                                    endif
                                    return s:cflags['php']
                                endif
                                return ''
                            endfunction " }}}2
                            
                            " try to find the ruby headers with 'rbconfig'
    1              0.000006 function! s:_check_ruby() " {{{2
                                if executable('ruby')
                                    if !has_key(s:cflags, 'ruby')
                                        let s:cflags['ruby'] = system('ruby -r rbconfig -e ' .
                                            \ '''puts RbConfig::CONFIG["rubyhdrdir"] || RbConfig::CONFIG["archdir"]''')
                                        let s:cflags['ruby'] = substitute(s:cflags['ruby'], "\n", '', '')
                                        let s:cflags['ruby'] = ' -I' . s:cflags['ruby']
                                    endif
                                    return s:cflags['ruby']
                                endif
                                return ''
                            endfunction " }}}2
                            
                            " try to find the python headers with distutils
    1              0.000006 function! s:_check_python() " {{{2
                                if executable('python')
                                    if !has_key(s:cflags, 'python')
                                        let s:cflags['python'] = system('python -c ''from distutils import ' .
                                            \ 'sysconfig; import sys; sys.stdout.write(sysconfig.get_python_inc())''')
                                        let s:cflags['python'] = substitute(s:cflags['python'], "\n", '', '')
                                        let s:cflags['python'] = ' -I' . s:cflags['python']
                                    endif
                                    return s:cflags['python']
                                endif
                                return ''
                            endfunction " }}}2
                            
                            " }}}1
                            
                            " default include directories
    1   0.000090   0.000060 let s:default_includes = [
                                \ '.',
                                \ '..',
                                \ 'include',
                                \ 'includes',
                                \ '..' . syntastic#util#Slash() . 'include',
                                \ '..' . syntastic#util#Slash() . 'includes' ]
                            
    1   0.001007   0.000025 call s:_init()
                            
    1              0.000029 let &cpo = s:save_cpo
    1              0.000006 unlet s:save_cpo
                            
                            " vim: set sw=4 sts=4 et fdm=marker:

FUNCTION  airline#parts#filetype()
Called 56 times
Total time:   0.000397
 Self time:   0.000397

count  total (s)   self (s)
   56              0.000321   return &filetype

FUNCTION  <SNR>93_ClearCache()
Called 2 times
Total time:   0.005380
 Self time:   0.000206

count  total (s)   self (s)
    2   0.004825   0.000078     call s:notifiers.reset(g:SyntasticLoclist.current())
    2   0.000549   0.000122     call b:syntastic_loclist.destroy()

FUNCTION  <SNR>161__isDebugEnabled_smart()
Called 51 times
Total time:   0.000515
 Self time:   0.000515

count  total (s)   self (s)
   51              0.000438     return and(g:syntastic_debug, a:level)

FUNCTION  bufferline#refresh_status()
Called 56 times
Total time:   0.035289
 Self time:   0.002971

count  total (s)   self (s)
   56              0.000363   if g:bufferline_solo_highlight
                                if g:bufferline_status_info.count == 1
                                  exec printf('highlight! link %s %s', g:bufferline_active_highlight, g:bufferline_inactive_highlight)
                                else
                                  exec printf('highlight! link %s NONE', g:bufferline_active_highlight)
                                endif
                              endif
   56   0.033220   0.000902   call bufferline#get_echo_string()
   56              0.000143   return ''

FUNCTION  syntastic#log#debug()
Called 43 times
Total time:   0.001255
 Self time:   0.000838

count  total (s)   self (s)
   43   0.001021   0.000604     if !s:isDebugEnabled(a:level)
   43              0.000125         return
                                endif
                            
                                let leader = s:_logTimestamp()
                                call s:_logRedirect(1)
                            
                                if a:0 > 0
                                    " filter out dictionary functions
                                    echomsg leader . a:msg . ' ' . strtrans(string(type(a:1) == type({}) || type(a:1) == type([]) ? filter(copy(a:1), 'type(v:val) != type(function("tr"))') : a:1))
                                else
                                    echomsg leader . a:msg
                                endif
                            
                                call s:_logRedirect(0)

FUNCTION  syntastic#log#debugShowOptions()
Called 2 times
Total time:   0.000061
 Self time:   0.000040

count  total (s)   self (s)
    2   0.000051   0.000030     if !s:isDebugEnabled(a:level)
    2              0.000005         return
                                endif
                            
                                let leader = s:_logTimestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = copy(type(a:names) == type("") ? [a:names] : a:names)
                                if !empty(vlist)
                                    call map(vlist, "'&' . v:val . ' = ' . strtrans(string(eval('&' . v:val)))")
                                    echomsg leader . join(vlist, ', ')
                                endif
                                call s:_logRedirect(0)

FUNCTION  airline#check_mode()
Called 56 times
Total time:   0.012542
 Self time:   0.012542

count  total (s)   self (s)
   56              0.000891   let context = s:contexts[a:winnr]
                            
   56              0.000585   if get(w:, 'airline_active', 1)
   56              0.000537     let l:m = mode()
   56              0.000332     if l:m ==# "i"
                                  let l:mode = ['insert']
                                elseif l:m ==# "R"
                                  let l:mode = ['replace']
                                elseif l:m =~# '\v(v|V||s|S|)'
                                  let l:mode = ['visual']
                                else
   56              0.000383       let l:mode = ['normal']
   56              0.000137     endif
   56              0.000825     let w:airline_current_mode = get(g:airline_mode_map, l:m, l:m)
   56              0.000124   else
                                let l:mode = ['inactive']
                                let w:airline_current_mode = get(g:airline_mode_map, '__')
                              endif
                            
   56              0.000536   if g:airline_detect_modified && &modified
                                call add(l:mode, 'modified')
                              endif
                            
   56              0.000266   if g:airline_detect_paste && &paste
                                call add(l:mode, 'paste')
                              endif
                            
   56              0.000251   if &readonly || ! &modifiable
                                call add(l:mode, 'readonly')
                              endif
                            
   56              0.000714   let mode_string = join(l:mode)
   56              0.000583   if get(w:, 'airline_lastmode', '') != mode_string
                                call airline#highlighter#highlight_modified_inactive(context.bufnr)
                                call airline#highlighter#highlight(l:mode)
                                let w:airline_lastmode = mode_string
                              endif
                            
   56              0.000178   return ''

FUNCTION  airline#util#append()
Called 168 times
Total time:   0.006041
 Self time:   0.006041

count  total (s)   self (s)
  168              0.001176   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  168              0.001973   let prefix = s:spc == "\ua0" ? s:spc : s:spc.s:spc
  168              0.001662   return empty(a:text) ? '' : prefix.g:airline_left_alt_sep.s:spc.a:text

FUNCTION  <SNR>67_generate_names()
Called 56 times
Total time:   0.023828
 Self time:   0.023828

count  total (s)   self (s)
   56              0.000351   let names = []
   56              0.000249   let i = 1
   56              0.000473   let last_buffer = bufnr('$')
   56              0.000416   let current_buffer = bufnr('%')
  112              0.000607   while i <= last_buffer
   56              0.000434     if bufexists(i) && buflisted(i)
   56              0.000296       let modified = ' '
   56              0.001121       if getbufvar(i, '&mod')
                                    let modified = g:bufferline_modified
                                  endif
   56              0.000797       let fname = fnamemodify(bufname(i), g:bufferline_fname_mod)
   56              0.001151       let fname = substitute(fname, "%", "%%", "g")
                            
   56              0.000272       let skip = 0
  112              0.000705       for ex in g:bufferline_excludes
   56              0.001068         if match(fname, ex) > -1
                                      let skip = 1
                                      break
                                    endif
   56              0.000147       endfor
                            
   56              0.000196       if !skip
   56              0.000314         let name = ''
   56              0.000521         if g:bufferline_show_bufnr != 0 && g:bufferline_status_info.count >= g:bufferline_show_bufnr
   56              0.000568           let name =  i . ':'
   56              0.000116         endif
   56              0.000521         let name .= fname . modified
                            
   56              0.000239         if current_buffer == i
   56              0.000619           let name = g:bufferline_active_buffer_left . name . g:bufferline_active_buffer_right
   56              0.000422           let g:bufferline_status_info.current = name
   56              0.000096         else
                                      let name = g:bufferline_separator . name . g:bufferline_separator
                                    endif
                            
   56              0.001286         call add(names, [i, name])
   56              0.000148       endif
   56              0.000080     endif
   56              0.000275     let i += 1
   56              0.000140   endwhile
                            
   56              0.000316   if len(names) > 1
                                if g:bufferline_rotate == 1
                                  call bufferline#algos#fixed_position#modify(names)
                                endif
                              endif
                            
   56              0.000173   return names

FUNCTION  <SNR>59_addtomrufs()
Called 2 times
Total time:   0.000589
 Self time:   0.000589

count  total (s)   self (s)
    2              0.000060 	let fn = fnamemodify(a:fname, ':p')
    2              0.000060 	let fn = exists('+ssl') ? tr(fn, '/', '\') : fn
    2              0.000327 	if ( !empty({s:in}) && fn !~# {s:in} ) || ( !empty({s:ex}) && fn =~# {s:ex} ) || !empty(getbufvar('^'.fn.'$', '&bt')) || !filereadable(fn) | retu
                            	en
    2              0.000045 	let idx = index(s:mrufs, fn, 0, !{s:cseno})
    2              0.000008 	if idx
                            		cal filter(s:mrufs, 'v:val !='.( {s:cseno} ? '#' : '?' ).' fn')
                            		cal insert(s:mrufs, fn)
                            		if {s:soup} && idx < 0
                            			cal s:savetofile(s:mergelists())
                            		en
                            	en

FUNCTION  syntastic#util#shescape()
Called 16 times
Total time:   0.000461
 Self time:   0.000461

count  total (s)   self (s)
   16              0.000441     return a:string =~ '\m^[A-Za-z0-9_/.-]\+$' ? a:string : shellescape(a:string)

FUNCTION  360()
Called 18 times
Total time:   0.010020
 Self time:   0.001498

count  total (s)   self (s)
   18   0.005786   0.000587     let checker = g:SyntasticChecker.New(a:args)
   18   0.001280   0.000436     let registry = g:SyntasticRegistry.Instance()
   18   0.002871   0.000392     call registry._registerChecker(checker)

FUNCTION  <SNR>159_ParseTagline()
Called 8 times
Total time:   0.005452
 Self time:   0.004203

count  total (s)   self (s)
    8              0.000117     let basic_info  = split(a:part1, '\t')
                            
    8   0.000832   0.000122     let taginfo      = s:NormalTag.New(basic_info[0])
    8              0.000055     let taginfo.file = basic_info[1]
                            
                                " the pattern can contain tabs and thus may have been split up, so join
                                " the rest of the items together again
    8              0.000088     let pattern = join(basic_info[2:], "\t")
    8              0.000030     let start   = 2 " skip the slash and the ^
    8              0.000059     let end     = strlen(pattern) - 1
    8              0.000049     if pattern[end - 1] ==# '$'
    8              0.000034         let end -= 1
    8              0.000030         let dollar = '\$'
    8              0.000014     else
                                    let dollar = ''
                                endif
    8              0.000070     let pattern         = strpart(pattern, start, end - start)
    8              0.000063     let taginfo.pattern = '\V\^\C' . pattern . dollar
                            
                                " When splitting fields make sure not to create empty keys or values in
                                " case a value illegally contains tabs
    8              0.000224     let fields = split(a:part2, '^\t\|\t\ze\w\+:')
    8              0.000110     let taginfo.fields.kind = remove(fields, 0)
   24              0.000079     for field in fields
                                    " can't use split() since the value can contain ':'
   16              0.000103         let delimit = stridx(field, ':')
   16              0.000103         let key = strpart(field, 0, delimit)
                                    " Remove all tabs that may illegally be in the value
   16              0.000249         let val = substitute(strpart(field, delimit + 1), '\t', '', 'g')
   16              0.000098         if len(val) > 0
   16              0.000072             if key == 'line' || key == 'column'
    8              0.000060                 let taginfo.fields[key] = str2nr(val)
    8              0.000015             else
    8              0.000045                 let taginfo.fields[key] = val
    8              0.000011             endif
   16              0.000022         endif
   16              0.000026     endfor
                                " Needed for jsctags
    8              0.000042     if has_key(taginfo.fields, 'lineno')
                                    let taginfo.fields.line = str2nr(taginfo.fields.lineno)
                                endif
                                " Do some sanity checking in case ctags reports invalid line numbers
    8              0.000026     if taginfo.fields.line < 0
                                    let taginfo.fields.line = 0
                                endif
                            
                                " Make some information easier accessible
    8              0.000036     if has_key(a:typeinfo, 'scope2kind')
   48              0.000162         for scope in keys(a:typeinfo.scope2kind)
   40              0.000193             if has_key(taginfo.fields, scope)
                                            let taginfo.scope = scope
                                            let taginfo.path  = taginfo.fields[scope]
                            
                                            let taginfo.fullpath = taginfo.path . a:typeinfo.sro . taginfo.name
                                            break
                                        endif
   40              0.000064         endfor
    8              0.000136         let taginfo.depth = len(split(taginfo.path, '\V' . a:typeinfo.sro))
    8              0.000015     endif
                            
    8              0.000038     let taginfo.fileinfo = a:fileinfo
    8              0.000032     let taginfo.typeinfo = a:typeinfo
                            
                                " Needed for folding
    8              0.000022     try
    8   0.000621   0.000082         call taginfo.initFoldState()
    8              0.000023     catch /^Vim(\a\+):E716:/ " 'Key not present in Dictionary'
                                    " The tag has a 'kind' that doesn't exist in the type definition
                                    call s:debug('ERROR Unknown tag kind: ' . taginfo.fields.kind)
                                    echoerr 'Unknown tag kind encountered: ' . taginfo.fields.kind 'Your ctags and Tagbar configurations are out of sync!' 'Please read '':help tagbar-extend''.'
                                endtry
                            
    8              0.000020     return taginfo

FUNCTION  airline#parts#iminsert()
Called 56 times
Total time:   0.001226
 Self time:   0.001226

count  total (s)   self (s)
   56              0.000527   if g:airline_detect_iminsert && &iminsert && exists('b:keymap_name')
                                return toupper(b:keymap_name)
                              endif
   56              0.000137   return ''

FUNCTION  <SNR>159_GetNearbyTag()
Called 12 times
Total time:   0.003173
 Self time:   0.002805

count  total (s)   self (s)
   12              0.000062     if s:nearby_disabled
                                    return {}
                                endif
                            
   12   0.000365   0.000222     let fileinfo = s:known_files.getCurrent(a:forcecurrent)
   12              0.000073     if empty(fileinfo)
                                    return {}
                                endif
                            
   12              0.000074     let typeinfo = fileinfo.typeinfo
   12              0.000039     if a:0 > 0
                                    let curline = a:1
                                else
   12              0.000093         let curline = line('.')
   12              0.000027     endif
   12              0.000058     let tag = {}
                            
                                " If a tag appears in a file more than once (for example namespaces in
                                " C++) only one of them has a 'tline' entry and can thus be highlighted.
                                " The only way to solve this would be to go over the whole tag list again,
                                " making everything slower. Since this should be a rare occurence and
                                " highlighting isn't /that/ important ignore it for now.
   41              0.000274     for line in range(curline, 1, -1)
   41              0.000293         if has_key(fileinfo.fline, line)
   12              0.000110             let curtag = fileinfo.fline[line]
   12   0.000422   0.000197             if a:all || typeinfo.getKind(curtag.fields.kind).stl
   12              0.000074                 let tag = curtag
   12              0.000031                 break
                                        endif
                                    endif
   29              0.000095     endfor
                            
   12              0.000038     return tag

FUNCTION  syntastic#util#Slash()
Called 2 times
Total time:   0.000030
 Self time:   0.000030

count  total (s)   self (s)
    2              0.000025     return (!exists("+shellslash") || &shellslash) ? '/' : '\'

FUNCTION  <SNR>120_Highlight_Matching_Pair()
Called 52 times
Total time:   0.012277
 Self time:   0.012277

count  total (s)   self (s)
                              " Remove any previous match.
   52              0.000586   if exists('w:paren_hl_on') && w:paren_hl_on
                                silent! call matchdelete(3)
                                let w:paren_hl_on = 0
                              endif
                            
                              " Avoid that we remove the popup menu.
                              " Return when there are no colors (looks like the cursor jumps).
   52              0.001425   if pumvisible() || (&t_Co < 8 && !has("gui_running"))
                                return
                              endif
                            
                              " Get the character under the cursor and check if it's in 'matchpairs'.
   52              0.000629   let c_lnum = line('.')
   52              0.000493   let c_col = col('.')
   52              0.000298   let before = 0
                            
   52              0.000544   let text = getline(c_lnum)
   52              0.000665   let c = text[c_col - 1]
   52              0.002544   let plist = split(&matchpairs, '.\zs[:,]')
   52              0.000659   let i = index(plist, c)
   52              0.000237   if i < 0
                                " not found, in Insert mode try character before the cursor
   52              0.000566     if c_col > 1 && (mode() == 'i' || mode() == 'R')
                                  let before = 1
                                  let c = text[c_col - 2]
                                  let i = index(plist, c)
                                endif
   52              0.000177     if i < 0
                                  " not found, nothing to do
   52              0.000145       return
                                endif
                              endif
                            
                              " Figure out the arguments for searchpairpos().
                              if i % 2 == 0
                                let s_flags = 'nW'
                                let c2 = plist[i + 1]
                              else
                                let s_flags = 'nbW'
                                let c2 = c
                                let c = plist[i - 1]
                              endif
                              if c == '['
                                let c = '\['
                                let c2 = '\]'
                              endif
                            
                              " Find the match.  When it was just before the cursor move it there for a
                              " moment.
                              if before > 0
                                let has_getcurpos = exists("*getcurpos")
                                if has_getcurpos
                                  " getcurpos() is more efficient but doesn't exist before 7.4.313.
                                  let save_cursor = getcurpos()
                                else
                                  let save_cursor = winsaveview()
                                endif
                                call cursor(c_lnum, c_col - before)
                              endif
                            
                              " Build an expression that detects whether the current cursor position is in
                              " certain syntax types (string, comment, etc.), for use as searchpairpos()'s
                              " skip argument.
                              " We match "escape" for special items, such as lispEscapeSpecial.
                              let s_skip = '!empty(filter(map(synstack(line("."), col(".")), ''synIDattr(v:val, "name")''), ' . '''v:val =~? "string\\|character\\|singlequote\\|escape\\|comment"''))'
                              " If executing the expression determines that the cursor is currently in
                              " one of the syntax types, then we want searchpairpos() to find the pair
                              " within those syntax types (i.e., not skip).  Otherwise, the cursor is
                              " outside of the syntax types and s_skip should keep its value so we skip any
                              " matching pair inside the syntax types.
                              execute 'if' s_skip '| let s_skip = 0 | endif'
                            
                              " Limit the search to lines visible in the window.
                              let stoplinebottom = line('w$')
                              let stoplinetop = line('w0')
                              if i % 2 == 0
                                let stopline = stoplinebottom
                              else
                                let stopline = stoplinetop
                              endif
                            
                              " Limit the search time to 300 msec to avoid a hang on very long lines.
                              " This fails when a timeout is not supported.
                              if mode() == 'i' || mode() == 'R'
                                let timeout = exists("b:matchparen_insert_timeout") ? b:matchparen_insert_timeout : g:matchparen_insert_timeout
                              else
                                let timeout = exists("b:matchparen_timeout") ? b:matchparen_timeout : g:matchparen_timeout
                              endif
                              try
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline, timeout)
                              catch /E118/
                                " Can't use the timeout, restrict the stopline a bit more to avoid taking
                                " a long time on closed folds and long lines.
                                " The "viewable" variables give a range in which we can scroll while
                                " keeping the cursor at the same position.
                                " adjustedScrolloff accounts for very large numbers of scrolloff.
                                let adjustedScrolloff = min([&scrolloff, (line('w$') - line('w0')) / 2])
                                let bottom_viewable = min([line('$'), c_lnum + &lines - adjustedScrolloff - 2])
                                let top_viewable = max([1, c_lnum-&lines+adjustedScrolloff + 2])
                                " one of these stoplines will be adjusted below, but the current values are
                                " minimal boundaries within the current window
                                if i % 2 == 0
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = min([line2byte("$"), line2byte(".") + col(".") + &smc * 2])
                            	let stopline = min([bottom_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = min([bottom_viewable, c_lnum + 100])
                                  endif
                                  let stoplinebottom = stopline
                                else
                                  if has("byte_offset") && has("syntax_items") && &smc > 0
                            	let stopbyte = max([1, line2byte(".") + col(".") - &smc * 2])
                            	let stopline = max([top_viewable, byte2line(stopbyte)])
                                  else
                            	let stopline = max([top_viewable, c_lnum - 100])
                                  endif
                                  let stoplinetop = stopline
                                endif
                                let [m_lnum, m_col] = searchpairpos(c, '', c2, s_flags, s_skip, stopline)
                              endtry
                            
                              if before > 0
                                if has_getcurpos
                                  call setpos('.', save_cursor)
                                else
                                  call winrestview(save_cursor)
                                endif
                              endif
                            
                              " If a match is found setup match highlighting.
                              if m_lnum > 0 && m_lnum >= stoplinetop && m_lnum <= stoplinebottom 
                                if exists('*matchaddpos')
                                  call matchaddpos('MatchParen', [[c_lnum, c_col - before], [m_lnum, m_col]], 10, 3)
                                else
                                  exe '3match MatchParen /\(\%' . c_lnum . 'l\%' . (c_col - before) . 'c\)\|\(\%' . m_lnum . 'l\%' . m_col . 'c\)/'
                                endif
                                let w:paren_hl_on = 1
                              endif

FUNCTION  sy#util#run_in_dir()
Called 2 times
Total time:   0.054533
 Self time:   0.000774

count  total (s)   self (s)
    2              0.000021   let chdir = haslocaldir() ? 'lcd' : 'cd'
    2              0.000026   let cwd   = getcwd()
                            
    2              0.000009   try
    2              0.000174     execute chdir fnameescape(fnamemodify(a:dir, ':p'))
    2   0.054057   0.000298     let ret = system(a:cmd)
    2              0.000027   finally
    2              0.000177     execute chdir fnameescape(cwd)
    2              0.000008   endtry
                            
    2              0.000015   return ret

FUNCTION  <SNR>59_record()
Called 2 times
Total time:   0.000874
 Self time:   0.000285

count  total (s)   self (s)
    2              0.000039 	if s:locked | retu | en
    2              0.000028 	let bufnr = a:bufnr + 0
    2              0.000024 	let bufname = bufname(bufnr)
    2              0.000022 	if bufnr > 0 && !empty(bufname)
    2              0.000060 		cal filter(s:mrbs, 'v:val != bufnr')
    2              0.000027 		cal insert(s:mrbs, bufnr)
    2   0.000654   0.000065 		cal s:addtomrufs(bufname)
    2              0.000005 	en

FUNCTION  303()
Called 1 time
Total time:   0.000094
 Self time:   0.000060

count  total (s)   self (s)
    1              0.000014     let leader = self._filetype . '/' . self._name . ': '
    1              0.000005     if a:0 > 0
    1   0.000057   0.000023         call syntastic#log#debug(g:SyntasticDebugCheckers, leader . a:msg, a:1)
    1              0.000003     else
                                    call syntastic#log#debug(g:SyntasticDebugCheckers, leader . a:msg)
                                endif

FUNCTION  305()
Called 2 times
Total time:   0.000560
 Self time:   0.000062

count  total (s)   self (s)
    2              0.000015     if !has_key(self, '_available')
    1   0.000528   0.000030         let self._available = self._isAvailableFunc()
    1              0.000003     endif
    2              0.000007     return self._available

FUNCTION  306()
Called 2 times
Total time:   0.000417
 Self time:   0.000273

count  total (s)   self (s)
                                " wildcard quiet_messages
    2   0.000092   0.000041     let quiet_filters = copy(syntastic#util#var('quiet_messages', {}))
    2              0.000019     if type(quiet_filters) != type({})
                                    call syntastic#log#warn('ignoring invalid syntastic_quiet_messages')
                                    unlet quiet_filters
                                    let quiet_filters = {}
                                endif
                            
                                " per checker quiet_messages
    2              0.000016     let name = self._filetype . '_' . self._name
    2              0.000006     try
    2   0.000102   0.000059         call extend( quiet_filters, copy(syntastic#util#var(name . '_quiet_messages', {})), 'force' )
    2              0.000008     catch /\m^Vim\%((\a\+)\)\=:E712/
                                    call syntastic#log#warn('ignoring invalid syntastic_' . name . '_quiet_messages')
                                endtry
                            
    2   0.000079   0.000029     call syntastic#log#debug(g:SyntasticDebugLoclist, 'quiet_messages filter:', quiet_filters)
                            
    2              0.000011     if !empty(quiet_filters)
                                    call syntastic#util#dictFilter(a:errors, quiet_filters)
                                    call syntastic#log#debug(g:SyntasticDebugLoclist, 'filtered by quiet_messages:', a:errors)
                                endif

FUNCTION  bufferline#get_echo_string()
Called 56 times
Total time:   0.032318
 Self time:   0.008490

count  total (s)   self (s)
                              " check for special cases like help files
   56              0.000635   let current = bufnr('%')
   56              0.000543   if !bufexists(current) || !buflisted(current)
                                return bufname('%')
                              endif
                            
   56   0.024785   0.000957   let names = s:generate_names()
   56              0.000249   let line = ''
  112              0.000461   for val in names
   56              0.000572     let line .= val[1]
   56              0.000158   endfor
                            
   56              0.001417   let index = match(line, '\V'.g:bufferline_status_info.current)
   56              0.000515   let g:bufferline_status_info.count = len(names)
   56              0.000625   let g:bufferline_status_info.before = strpart(line, 0, index)
   56              0.000845   let g:bufferline_status_info.after = strpart(line, index + len(g:bufferline_status_info.current))
   56              0.000210   return line

FUNCTION  syntastic#util#stamp()
Called 6 times
Total time:   0.000060
 Self time:   0.000060

count  total (s)   self (s)
    6              0.000051     return reltime(g:syntastic_start)

FUNCTION  311()
Called 4 times
Total time:   0.000109
 Self time:   0.000035

count  total (s)   self (s)
    4   0.000106   0.000032     return syntastic#util#var('echo_current_error')

FUNCTION  312()
Called 2 times
Total time:   0.000157
 Self time:   0.000086

count  total (s)   self (s)
    2   0.000099   0.000028     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:SyntasticDebugNotifications, 'cursor: refresh')
                                    let b:syntastic_messages = copy(a:loclist.messages(bufnr('')))
                                    let b:syntastic_line = -1
                                    let b:syntastic_cursor_columns = a:loclist.getCursorColumns()
                                    autocmd! syntastic CursorMoved
                                    autocmd syntastic CursorMoved * call SyntasticRefreshCursor()
                                endif

FUNCTION  313()
Called 2 times
Total time:   0.000165
 Self time:   0.000103

count  total (s)   self (s)
    2   0.000098   0.000036     call syntastic#log#debug(g:SyntasticDebugNotifications, 'cursor: reset')
    2              0.000032     autocmd! syntastic CursorMoved
    2              0.000012     unlet! b:syntastic_messages
    2              0.000016     let b:syntastic_line = -1

FUNCTION  315()
Called 4 times
Total time:   0.000118
 Self time:   0.000044

count  total (s)   self (s)
    4   0.000112   0.000038     return s:has_highlighting && syntastic#util#var('enable_highlighting')

FUNCTION  316()
Called 2 times
Total time:   0.002090
 Self time:   0.000360

count  total (s)   self (s)
    2   0.000068   0.000013     if self.enabled()
    2   0.000061   0.000024         call syntastic#log#debug(g:SyntasticDebugNotifications, 'highlighting: refresh')
    2   0.001630   0.000017         call self._reset()
    2              0.000013         let buf = bufnr('')
    2   0.000179   0.000154         let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
    2              0.000011         for item in issues
                                        let group = 'Syntastic' . get(item, 'subtype', '') . ( item['type'] ==? 'E' ? 'Error' : 'Warning' )
                            
                                        " The function `Syntastic_{filetype}_{checker}_GetHighlightRegex` is
                                        " used to override default highlighting.
                                        if has_key(item, 'hl')
                                            call matchadd(group, '\%' . item['lnum'] . 'l' . item['hl'])
                                        elseif get(item, 'col', 0)
                                            if get(item, 'vcol', 0)
                                                let lastcol = virtcol([item['lnum'], '$'])
                                                let coltype = 'v'
                                            else
                                                let lastcol = col([item['lnum'], '$'])
                                                let coltype = 'c'
                                            endif
                                            let lcol = min([lastcol, item['col']])
                            
                                            call matchadd(group, '\%' . item['lnum'] . 'l\%' . lcol . coltype)
                                        endif
                                    endfor
    2              0.000006     endif

FUNCTION  317()
Called 2 times
Total time:   0.002963
 Self time:   0.000096

count  total (s)   self (s)
    2              0.000013     if s:has_highlighting
    2   0.000093   0.000035         call syntastic#log#debug(g:SyntasticDebugNotifications, 'highlighting: reset')
    2   0.002845   0.000036         call self._reset()
    2              0.000006     endif

FUNCTION  319()
Called 4 times
Total time:   0.004422
 Self time:   0.004422

count  total (s)   self (s)
  236              0.001151     for match in getmatches()
  232              0.001478         if stridx(match['group'], 'Syntastic') == 0
                                        call matchdelete(match['id'])
                                    endif
  232              0.000382     endfor

FUNCTION  <SNR>93_UpdateErrors()
Called 2 times
Total time:   1.227357
 Self time:   0.000776

count  total (s)   self (s)
    2   0.000133   0.000063     call syntastic#log#debugShowVariables(g:SyntasticDebugTrace, 'version')
    2   0.000121   0.000060     call syntastic#log#debugShowOptions(g:SyntasticDebugTrace, s:debug_dump_options)
    2   0.000115   0.000045     call syntastic#log#debugDump(g:SyntasticDebugVariables)
    2   0.000071   0.000038     call syntastic#log#debug(g:SyntasticDebugTrace, 'UpdateErrors' . (a:auto_invoked ? ' (auto)' : '') . ': ' . (a:0 ? join(a:000) : 'default checkers'))
    2   0.000556   0.000056     if s:skipFile()
                                    return
                                endif
                            
    2   0.000201   0.000047     call s:modemap.synch()
    2   0.000337   0.000059     let run_checks = !a:auto_invoked || s:modemap.allowsAutoChecking(&filetype)
    2              0.000012     if run_checks
    2   1.219683   0.000091         call s:CacheErrors(a:000)
    2              0.000005     endif
                            
    2   0.000098   0.000041     let loclist = g:SyntasticLoclist.current()
                            
                                " populate loclist and jump {{{3
    2   0.000072   0.000026     let do_jump = syntastic#util#var('auto_jump')
    2              0.000007     if do_jump == 2
                                    let first = loclist.getFirstIssue()
                                    let type = get(first, 'type', '')
                                    let do_jump = type ==? 'E'
                                endif
                            
    2              0.000011     let w:syntastic_loclist_set = 0
    2   0.000065   0.000022     if syntastic#util#var('always_populate_loc_list') || do_jump
                                    call syntastic#log#debug(g:SyntasticDebugNotifications, 'loclist: setloclist (new)')
                                    call setloclist(0, loclist.getRaw())
                                    let w:syntastic_loclist_set = 1
                                    if run_checks && do_jump && !loclist.isEmpty()
                                        call syntastic#log#debug(g:SyntasticDebugNotifications, 'loclist: jump')
                                        silent! lrewind
                            
                                        " XXX: Vim doesn't call autocmd commands in a predictible
                                        " order, which can lead to missing filetype when jumping
                                        " to a new file; the following is a workaround for the
                                        " resulting brain damage
                                        if &filetype == ''
                                            silent! filetype detect
                                        endif
                                    endif
                                endif
                                " }}}3
                            
    2   0.005722   0.000045     call s:notifiers.refresh(loclist)

FUNCTION  <SNR>210__init()
Called 1 time
Total time:   0.000982
 Self time:   0.000293

count  total (s)   self (s)
    1              0.000008     let s:handlers = []
    1              0.000006     let s:cflags = {}
                            
    1   0.000094   0.000031     call s:_regHandler('\m\<cairo',       's:_check_pkg', ['cairo', 'cairo'])
    1   0.000071   0.000021     call s:_regHandler('\m\<freetype',    's:_check_pkg', ['freetype', 'freetype2', 'freetype'])
    1   0.000071   0.000020     call s:_regHandler('\m\<glade',       's:_check_pkg', ['glade', 'libglade-2.0', 'libglade'])
    1   0.000067   0.000018     call s:_regHandler('\m\<glib',        's:_check_pkg', ['glib', 'glib-2.0', 'glib'])
    1   0.000066   0.000019     call s:_regHandler('\m\<gtk',         's:_check_pkg', ['gtk', 'gtk+-2.0', 'gtk+', 'glib-2.0', 'glib'])
    1   0.000069   0.000020     call s:_regHandler('\m\<libsoup',     's:_check_pkg', ['libsoup', 'libsoup-2.4', 'libsoup-2.2'])
    1   0.000066   0.000018     call s:_regHandler('\m\<libxml',      's:_check_pkg', ['libxml', 'libxml-2.0', 'libxml'])
    1   0.000065   0.000017     call s:_regHandler('\m\<pango',       's:_check_pkg', ['pango', 'pango'])
    1   0.000065   0.000017     call s:_regHandler('\m\<SDL',         's:_check_pkg', ['sdl', 'sdl'])
    1   0.000066   0.000018     call s:_regHandler('\m\<opengl',      's:_check_pkg', ['opengl', 'gl'])
    1   0.000065   0.000017     call s:_regHandler('\m\<webkit',      's:_check_pkg', ['webkit', 'webkit-1.0'])
                            
    1   0.000063   0.000015     call s:_regHandler('\m\<php\.h\>',    's:_check_php',    [])
    1   0.000063   0.000016     call s:_regHandler('\m\<Python\.h\>', 's:_check_python', [])
    1   0.000061   0.000016     call s:_regHandler('\m\<ruby',        's:_check_ruby',   [])

FUNCTION  320()
Called 4 times
Total time:   0.000591
 Self time:   0.000591

count  total (s)   self (s)
    4              0.000161     let newObj = copy(self)
                            
    4              0.000108     let llist = filter(copy(a:rawLoclist), 'v:val["valid"] == 1')
                            
    4              0.000025     for e in llist
                                    if get(e, 'type', '') == ''
                                        let e['type'] = 'E'
                                    endif
                                endfor
                            
    4              0.000030     let newObj._rawLoclist = llist
    4              0.000022     let newObj._name = ''
    4              0.000034     let newObj._owner = bufnr('')
    4              0.000021     let newObj._sorted = 0
    4              0.000040     let newObj._columns = g:syntastic_cursor_columns
                            
    4              0.000019     return newObj

FUNCTION  321()
Called 60 times
Total time:   0.001770
 Self time:   0.001770

count  total (s)   self (s)
   60              0.000817     if !exists("b:syntastic_loclist") || empty(b:syntastic_loclist)
                                    let b:syntastic_loclist = g:SyntasticLoclist.New([])
                                endif
   60              0.000246     return b:syntastic_loclist

FUNCTION  324()
Called 12 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
   12              0.000102     return empty(self._rawLoclist)

FUNCTION  325()
Called 4 times
Total time:   0.000373
 Self time:   0.000172

count  total (s)   self (s)
    4              0.000062     if !exists("self._stamp")
                                    let self._stamp = []
                                    return 0
                                endif
    4   0.000259   0.000058     return syntastic#util#compareLexi(self._stamp, a:stamp) > 0

FUNCTION  326()
Called 2 times
Total time:   0.000025
 Self time:   0.000025

count  total (s)   self (s)
    2              0.000024     return copy(self._rawLoclist)

FUNCTION  307()
Called 2 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
    2              0.000017     if has_key(self, '_highlightRegexFunc')
                                    for e in a:errors
                                        if e['valid']
                                            let term = self._highlightRegexFunc(e)
                                            if term != ''
                                                let e['hl'] = term
                                            endif
                                        endif
                                    endfor
                                endif

FUNCTION  <SNR>147_check_mixed_indent()
Called 2 times
Total time:   0.001304
 Self time:   0.001304

count  total (s)   self (s)
    2              0.000014   if s:indent_algo == 1
                                " [<tab>]<space><tab>
                                " spaces before or between tabs are not allowed
                                let t_s_t = '(^\t* +\t\s*\S)'
                                " <tab>(<space> x count)
                                " count of spaces at the end of tabs should be less then tabstop value
                                let t_l_s = '(^\t+ {' . &ts . ',}' . '\S)'
                                return search('\v' . t_s_t . '|' . t_l_s, 'nw')
                              else
    2              0.001241     return search('\v(^\t+ +)|(^ +\t+)', 'nw')
                              endif

FUNCTION  330()
Called 56 times
Total time:   0.008888
 Self time:   0.008888

count  total (s)   self (s)
   56              0.000498     if !exists("self._stl_format")
    2              0.000019         let self._stl_format = ''
    2              0.000006     endif
   56              0.000342     if !exists("self._stl_flag")
    2              0.000011         let self._stl_flag = ''
    2              0.000005     endif
                            
   56              0.000347     if g:syntastic_stl_format !=# self._stl_format
    2              0.000015         let self._stl_format = g:syntastic_stl_format
                            
    2              0.000015         if !empty(self._rawLoclist)
                                        let errors = self.errors()
                                        let warnings = self.warnings()
                            
                                        let num_errors = len(errors)
                                        let num_warnings = len(warnings)
                                        let num_issues = len(self._rawLoclist)
                            
                                        let output = self._stl_format
                            
                                        "hide stuff wrapped in %E(...) unless there are errors
                                        let output = substitute(output, '\m\C%E{\([^}]*\)}', num_errors ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %W(...) unless there are warnings
                                        let output = substitute(output, '\m\C%W{\([^}]*\)}', num_warnings ? '\1' : '' , 'g')
                            
                                        "hide stuff wrapped in %B(...) unless there are both errors and warnings
                                        let output = substitute(output, '\m\C%B{\([^}]*\)}', (num_warnings && num_errors) ? '\1' : '' , 'g')
                            
                                        "sub in the total errors/warnings/both
                                        let output = substitute(output, '\m\C%w', num_warnings, 'g')
                                        let output = substitute(output, '\m\C%e', num_errors, 'g')
                                        let output = substitute(output, '\m\C%t', num_issues, 'g')
                            
                                        "first error/warning line num
                                        let output = substitute(output, '\m\C%F', num_issues ? self._rawLoclist[0]['lnum'] : '', 'g')
                            
                                        "first error line num
                                        let output = substitute(output, '\m\C%fe', num_errors ? errors[0]['lnum'] : '', 'g')
                            
                                        "first warning line num
                                        let output = substitute(output, '\m\C%fw', num_warnings ? warnings[0]['lnum'] : '', 'g')
                            
                                        let self._stl_flag = output
                                    else
    2              0.000010             let self._stl_flag = ''
    2              0.000005         endif
    2              0.000004     endif
                            
   56              0.000253     return self._stl_flag

FUNCTION  335()
Called 2 times
Total time:   0.000031
 Self time:   0.000031

count  total (s)   self (s)
    2              0.000027     let self._owner = type(a:buffer) == type(0) ? a:buffer : str2nr(a:buffer)

FUNCTION  336()
Called 2 times
Total time:   0.000431
 Self time:   0.000156

count  total (s)   self (s)
    2   0.000062   0.000031     call self.setOwner(bufnr(''))
    2   0.000069   0.000041     let self._stamp = syntastic#util#stamp()
    4   0.000248   0.000032     for buf in self.getBuffers()
    2              0.000030         call setbufvar(buf, 'syntastic_loclist', self)
    2              0.000004     endfor

FUNCTION  337()
Called 2 times
Total time:   0.000427
 Self time:   0.000127

count  total (s)   self (s)
    4   0.000353   0.000053     for buf in self.getBuffers()
    2              0.000045         call setbufvar(buf, 'syntastic_loclist', {})
    2              0.000005     endfor

FUNCTION  300()
Called 2 times
Total time:   1.141657
 Self time:   0.000073

count  total (s)   self (s)
    2   1.141654   0.000070     return g:SyntasticLoclist.New(self.getLocListRaw())

FUNCTION  347()
Called 2 times
Total time:   0.000154
 Self time:   0.000154

count  total (s)   self (s)
    2              0.000022     if exists('g:syntastic_mode_map')
                                    let self._mode = get(g:syntastic_mode_map, 'mode', 'active')
                                    let self._activeFiletypes = copy(get(g:syntastic_mode_map, 'active_filetypes', []))
                                    let self._passiveFiletypes = copy(get(g:syntastic_mode_map, 'passive_filetypes', []))
                                else
    2              0.000015         let self._mode = 'active'
    2              0.000022         let self._activeFiletypes = []
    2              0.000019         let self._passiveFiletypes = []
    2              0.000008     endif

FUNCTION  348()
Called 2 times
Total time:   0.000278
 Self time:   0.000157

count  total (s)   self (s)
    2              0.000046     let fts = split(a:filetype, '\m\.')
                            
    2   0.000058   0.000036     if self.isPassive()
                                    return self._isOneFiletypeActive(fts)
                                else
    2   0.000143   0.000044         return self._noFiletypesArePassive(fts)
                                endif

FUNCTION  349()
Called 2 times
Total time:   0.000022
 Self time:   0.000022

count  total (s)   self (s)
    2              0.000020     return self._mode ==# 'passive'

FUNCTION  <SNR>159_CompareByKind()
Called 12 times
Total time:   0.000785
 Self time:   0.000785

count  total (s)   self (s)
   12              0.000069     let typeinfo = s:compare_typeinfo
                            
   12              0.000084     if typeinfo.kinddict[a:tag1.fields.kind] <# typeinfo.kinddict[a:tag2.fields.kind]
                                    return -1
                                elseif typeinfo.kinddict[a:tag1.fields.kind] ># typeinfo.kinddict[a:tag2.fields.kind]
                                    return 1
                                else
                                    " Ignore '~' prefix for C++ destructors to sort them directly under
                                    " the constructors
   12              0.000056         if a:tag1.name[0] ==# '~'
                                        let name1 = a:tag1.name[1:]
                                    else
   12              0.000050             let name1 = a:tag1.name
   12              0.000018         endif
   12              0.000049         if a:tag2.name[0] ==# '~'
                                        let name2 = a:tag2.name[1:]
                                    else
   12              0.000045             let name2 = a:tag2.name
   12              0.000020         endif
                            
   12              0.000037         if name1 <=# name2
    8              0.000015             return -1
                                    else
    4              0.000007             return 1
                                    endif
                                endif

FUNCTION  354()
Called 2 times
Total time:   0.000099
 Self time:   0.000099

count  total (s)   self (s)
    2              0.000095     return empty(filter(copy(a:filetypes), 'index(self._passiveFiletypes, v:val) != -1'))

FUNCTION  356()
Called 2 times
Total time:   0.005677
 Self time:   0.001464

count  total (s)   self (s)
    2   0.000041   0.000025     if !a:loclist.isEmpty() && !a:loclist.isNewerThan([])
                                    " loclist not fully constructed yet
                                    return
                                endif
                            
    2   0.000070   0.000024     call syntastic#log#debug(g:SyntasticDebugNotifications, 'notifiers: refresh')
   12              0.000045     for type in self._enabled_types
   10              0.000270         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
   10   0.000494   0.000224         if !has_key(g:{class}, 'enabled') || self._notifier[type].enabled()
   10              0.000082             if index(s:persistent_notifiers, type) > -1
                                            " refresh only if loclist has changed since last call
    4              0.000036                 if !exists('b:syntastic_' . type . '_stamp')
                                                let b:syntastic_{type}_stamp = []
                                            endif
    4   0.000446   0.000073                 if a:loclist.isNewerThan(b:syntastic_{type}_stamp) || a:loclist.isEmpty()
    4   0.000932   0.000067                     call self._notifier[type].refresh(a:loclist)
    4   0.000099   0.000067                     let b:syntastic_{type}_stamp = syntastic#util#stamp()
    4              0.000007                 endif
    4              0.000006             else
    6   0.002750   0.000139                 call self._notifier[type].refresh(a:loclist)
    6              0.000022             endif
   10              0.000010         endif
   10              0.000016     endfor

FUNCTION  357()
Called 2 times
Total time:   0.004673
 Self time:   0.001259

count  total (s)   self (s)
    2   0.000092   0.000035     call syntastic#log#debug(g:SyntasticDebugNotifications, 'notifiers: reset')
   12              0.000062     for type in self._enabled_types
   10              0.000367         let class = substitute(type, '\m.*', 'Syntastic\u&Notifier', '')
                            
                                    " reset notifiers regardless if they are enabled or not, since
                                    " the user might have disabled them since the last refresh();
                                    " notifiers MUST be prepared to deal with reset() when disabled
   10              0.000172         if has_key(g:{class}, 'reset')
    6   0.003509   0.000152             call self._notifier[type].reset(a:loclist)
    6              0.000014         endif
                            
                                    " also reset stamps
   10              0.000104         if index(s:persistent_notifiers, type) > -1
    4              0.000073             let b:syntastic_{type}_stamp = []
    4              0.000011         endif
   10              0.000024     endfor

FUNCTION  359()
Called 18 times
Total time:   0.000844
 Self time:   0.000844

count  total (s)   self (s)
   18              0.000274     if !exists('s:SyntasticRegistryInstance')
                                    let s:SyntasticRegistryInstance = copy(self)
                                    let s:SyntasticRegistryInstance._checkerMap = {}
                                endif
                            
   18              0.000153     return s:SyntasticRegistryInstance

FUNCTION  366()
Called 18 times
Total time:   0.002479
 Self time:   0.002123

count  total (s)   self (s)
   18   0.000548   0.000371     let ft = a:checker.getFiletype()
   18              0.000283     if !has_key(self._checkerMap, ft)
    2              0.000035         let self._checkerMap[ft] = {}
    2              0.000008     endif
                            
   18   0.000538   0.000359     let name = a:checker.getName()
   18              0.000247     if has_key(self._checkerMap[ft], name)
                                    throw 'Syntastic: Duplicate syntax checker name: ' . ft . '/' . name
                                endif
                            
   18              0.000278     let self._checkerMap[ft][name] = a:checker

FUNCTION  367()
Called 2 times
Total time:   0.000079
 Self time:   0.000079

count  total (s)   self (s)
    2              0.000075     return filter( map(copy(a:list), 'get(a:checkers_map, v:val, {})'), '!empty(v:val)' )

FUNCTION  368()
Called 2 times
Total time:   0.068492
 Self time:   0.007153

count  total (s)   self (s)
    2              0.000023     if has_key(self._checkerMap, a:filetype)
    1              0.000001         return
                                endif
                            
    1   0.068428   0.007089     execute "runtime! syntax_checkers/" . a:filetype . "/*.vim"
                            
    1              0.000015     if !has_key(self._checkerMap, a:filetype)
                                    let self._checkerMap[a:filetype] = {}
                                endif

FUNCTION  369()
Called 2 times
Total time:   0.000057
 Self time:   0.000057

count  total (s)   self (s)
    2              0.000028     if exists('g:syntastic_' . a:filetype . '_checker') && !exists('g:syntastic_' . a:filetype . '_checkers')
                                    let g:syntastic_{a:filetype}_checkers = [g:syntastic_{a:filetype}_checker]
                                    call syntastic#log#oneTimeWarn('variable g:syntastic_' . a:filetype . '_checker is deprecated')
                                endif

FUNCTION  419()
Called 2 times
Total time:   0.000040
 Self time:   0.000040

count  total (s)   self (s)
    2              0.000015     if exists('self._tagfolds_old')
    2              0.000020         unlet self._tagfolds_old
    2              0.000003     endif

FUNCTION  371()
Called 4 times
Total time:   0.000166
 Self time:   0.000080

count  total (s)   self (s)
    4   0.000161   0.000075     return has('signs') && syntastic#util#var('enable_signs')

FUNCTION  372()
Called 2 times
Total time:   0.000656
 Self time:   0.000166

count  total (s)   self (s)
    2   0.000079   0.000029     call syntastic#log#debug(g:SyntasticDebugNotifications, 'signs: refresh')
    2   0.000083   0.000041     let old_signs = copy(self._bufSignIds())
    2   0.000101   0.000020     if self.enabled()
    2   0.000263   0.000034         call self._signErrors(a:loclist)
    2              0.000003     endif
    2   0.000120   0.000032     call self._removeSigns(old_signs)

FUNCTION  374()
Called 2 times
Total time:   0.000229
 Self time:   0.000212

count  total (s)   self (s)
    2              0.000013     let loclist = a:loclist
    2   0.000037   0.000020     if !loclist.isEmpty()
                            
                                    let buf = bufnr('')
                                    if !bufloaded(buf)
                                        " signs can be placed only in loaded buffers
                                        return
                                    endif
                            
                                    " errors come first, so that they are not masked by warnings
                                    let issues = copy(loclist.errors())
                                    call extend(issues, loclist.warnings())
                                    call filter(issues, 'v:val["bufnr"] == buf')
                                    let seen = {}
                            
                                    for i in issues
                                        if i['lnum'] > 0 && !has_key(seen, i['lnum'])
                                            let seen[i['lnum']] = 1
                            
                                            let sign_severity = i['type'] ==? 'W' ? 'Warning' : 'Error'
                                            let sign_subtype = get(i, 'subtype', '')
                                            let sign_type = 'Syntastic' . sign_subtype . sign_severity
                            
                                            execute "sign place " . s:next_sign_id . " line=" . i['lnum'] . " name=" . sign_type . " buffer=" . i['bufnr']
                                            call add(self._bufSignIds(), s:next_sign_id)
                                            let s:next_sign_id += 1
                                        endif
                                    endfor
                                endif

FUNCTION  375()
Called 2 times
Total time:   0.000088
 Self time:   0.000088

count  total (s)   self (s)
    2              0.000018     if has('signs')
    2              0.000031         for s in reverse(copy(a:ids))
                                        execute "sign unplace " . s
                                        call remove(self._bufSignIds(), index(self._bufSignIds(), s))
                                    endfor
    2              0.000003     endif

FUNCTION  376()
Called 2 times
Total time:   0.000042
 Self time:   0.000042

count  total (s)   self (s)
    2              0.000020     if !exists("b:syntastic_sign_ids")
                                    let b:syntastic_sign_ids = []
                                endif
    2              0.000007     return b:syntastic_sign_ids

FUNCTION  airline#util#wrap()
Called 448 times
Total time:   0.007300
 Self time:   0.007300

count  total (s)   self (s)
  448              0.003174   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
  448              0.001417   return a:text

FUNCTION  <SNR>210__getCflags()
Called 2 times
Total time:   0.006167
 Self time:   0.000600

count  total (s)   self (s)
                                " determine whether to parse header files as well
    2              0.000063     if has_key(a:opts, 'header_names') && expand('%') =~? a:opts['header_names']
                                    if s:_getCheckerVar('g', a:ft, a:ck, 'check_header', 0)
                                        let flags = get(a:opts, 'header_flags', '') . ' -c ' . syntastic#c#NullOutput()
                                    else
                                        " checking headers when check_header is unset: bail out
                                        throw 'Syntastic: skip checks'
                                    endif
                                else
    2              0.000017         let flags = get(a:opts, 'main_flags', '')
    2              0.000004     endif
                            
    2   0.001251   0.000088     let flags .= ' ' . s:_getCheckerVar('g', a:ft, a:ck, 'compiler_options', '') . ' ' . s:_getIncludeDirs(a:ft)
                            
                                " check if the user manually set some cflags
    2   0.000134   0.000041     let b_cflags = s:_getCheckerVar('b', a:ft, a:ck, 'cflags', '')
    2              0.000009     if b_cflags == ''
                                    " check whether to search for include files at all
    2   0.000112   0.000027         if !s:_getCheckerVar('g', a:ft, a:ck, 'no_include_search', 0)
    2              0.000011             if a:ft ==# 'c' || a:ft ==# 'cpp'
                                            " refresh the include file search if desired
    2   0.000108   0.000027                 if s:_getCheckerVar('g', a:ft, a:ck, 'auto_refresh_includes', 0)
                                                let flags .= ' ' . s:_searchHeaders()
                                            else
                                                " search for header includes if not cached already
    2              0.000018                     if !exists('b:syntastic_' . a:ft . '_includes')
    1   0.003386   0.000037                         let b:syntastic_{a:ft}_includes = s:_searchHeaders()
    1              0.000002                     endif
    2              0.000021                     let flags .= ' ' . b:syntastic_{a:ft}_includes
    2              0.000003                 endif
    2              0.000002             endif
    2              0.000002         endif
    2              0.000003     else
                                    " user-defined cflags
                                    let flags .= ' ' . b_cflags
                                endif
                            
                                " add optional config file parameters
    2   0.000130   0.000043     let config_file = s:_getCheckerVar('g', a:ft, a:ck, 'config_file', '.syntastic_' . a:ft . '_config')
    2   0.000756   0.000047     let flags .= ' ' . syntastic#c#ReadConfig(config_file)
                            
    2              0.000008     return flags

FUNCTION  386()
Called 10 times
Total time:   0.000891
 Self time:   0.000385

count  total (s)   self (s)
   10              0.000221     let newobj = copy(self)
                            
   10   0.000609   0.000103     call newobj._init(a:name)
                            
   10              0.000032     return newobj

FUNCTION  387()
Called 10 times
Total time:   0.000506
 Self time:   0.000506

count  total (s)   self (s)
   10              0.000057     let self.name          = a:name
   10              0.000044     let self.fields        = {}
   10              0.000041     let self.fields.line   = 0
   10              0.000034     let self.fields.column = 1
   10              0.000041     let self.prototype     = ''
   10              0.000036     let self.path          = ''
   10              0.000041     let self.fullpath      = a:name
   10              0.000032     let self.depth         = 0
   10              0.000036     let self.parent        = {}
   10              0.000031     let self.tline         = -1
   10              0.000036     let self.fileinfo      = {}
   10              0.000038     let self.typeinfo      = {}

FUNCTION  syntastic#log#debugShowVariables()
Called 4 times
Total time:   0.000135
 Self time:   0.000079

count  total (s)   self (s)
    4   0.000117   0.000061     if !s:isDebugEnabled(a:level)
    4              0.000012         return
                                endif
                            
                                let leader = s:_logTimestamp()
                                call s:_logRedirect(1)
                            
                                let vlist = type(a:names) == type("") ? [a:names] : a:names
                                for name in vlist
                                    let msg = s:_formatVariable(name)
                                    if msg != ''
                                        echomsg leader . msg
                                    endif
                                endfor
                            
                                call s:_logRedirect(0)

FUNCTION  393()
Called 8 times
Total time:   0.000539
 Self time:   0.000470

count  total (s)   self (s)
    8              0.000047     let fileinfo = self.fileinfo
                            
    8   0.000236   0.000167     if s:known_files.has(fileinfo.fpath) && has_key(fileinfo, '_tagfolds_old') && has_key(fileinfo._tagfolds_old[self.fields.kind], self.fullpath)
                                    " The file has been updated and the tag was there before, so copy its
                                    " old fold state
    8              0.000094         let fileinfo.tagfolds[self.fields.kind][self.fullpath] = fileinfo._tagfolds_old[self.fields.kind][self.fullpath]
    8              0.000030     elseif self.depth >= fileinfo.foldlevel
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] = 1
                                else
                                    let fileinfo.tagfolds[self.fields.kind][self.fullpath] = fileinfo.kindfolds[self.fields.kind]
                                endif

FUNCTION  sy#repo#get_diff_bzr()
Called 2 times
Total time:   0.541683
 Self time:   0.000572

count  total (s)   self (s)
    2              0.000042   let diffoptions = has_key(g:signify_diffoptions, 'bzr') ? g:signify_diffoptions.bzr : ''
    2   0.541469   0.000358   let diff = system('bzr diff --using '. s:difftool .' --diff-options=-U0 '. diffoptions .' -- '. sy#util#escape(b:sy.path))
                            
    2              0.000144   return (v:shell_error =~ '[012]') ? [1, diff] : [0, '']

FUNCTION  <SNR>144_get_git_branch()
Called 56 times
Total time:   0.001257
 Self time:   0.001257

count  total (s)   self (s)
   56              0.000669   if has_key(s:git_dirs, a:path)
   56              0.000416     return s:git_dirs[a:path]
                              endif
                            
                              let dir = fugitive#extract_git_dir(a:path)
                              if empty(dir)
                                let name = ''
                              else
                                try
                                  let line = join(readfile(dir . '/HEAD'))
                                  if strpart(line, 0, 16) == 'ref: refs/heads/'
                                    let name = strpart(line, 16)
                                  else
                                    " raw commit hash
                                    let name = strpart(line, 0, 7)
                                  endif
                                catch
                                  let name = ''
                                endtry
                              endif
                            
                              let s:git_dirs[a:path] = name
                              return name

FUNCTION  airline#extensions#whitespace#check()
Called 56 times
Total time:   0.008723
 Self time:   0.007419

count  total (s)   self (s)
   56              0.000757   if &readonly || !&modifiable || !s:enabled || line('$') > s:max_lines
                                return ''
                              endif
                            
   56              0.000492   if !exists('b:airline_whitespace_check')
    2              0.000021     let b:airline_whitespace_check = ''
    2              0.000030     let checks = get(g:, 'airline#extensions#whitespace#checks', s:default_checks)
                            
    2              0.000010     let trailing = 0
    2              0.000018     if index(checks, 'trailing') > -1
    2              0.000735       let trailing = search('\s$', 'nw')
    2              0.000007     endif
                            
    2              0.000011     let mixed = 0
    2              0.000017     if index(checks, 'indent') > -1
    2   0.001359   0.000055       let mixed = s:check_mixed_indent()
    2              0.000006     endif
                            
    2              0.000011     if trailing != 0 || mixed != 0
                                  let b:airline_whitespace_check = s:symbol
                                  if s:show_message
                                    if trailing != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:trailing_format, trailing)
                                    endif
                                    if mixed != 0
                                      let b:airline_whitespace_check .= (g:airline_symbols.space).printf(s:mixed_indent_format, mixed)
                                    endif
                                  endif
                                endif
    2              0.000003   endif
   56              0.000275   return b:airline_whitespace_check

FUNCTION  sy#start()
Called 2 times
Total time:   1.133032
 Self time:   0.000574

count  total (s)   self (s)
    2              0.000012   if g:signify_locked
                                return
                              endif
                            
    2              0.000015   if !exists('b:sy_path')
                                let b:sy_path = resolve(expand('%:p'))
                              endif
                            
    2              0.000121   if &diff || !filereadable(b:sy_path) || (exists('g:signify_skip_filetype') && (has_key(g:signify_skip_filetype, &ft)                                       || (has_key(g:signify_skip_filetype, 'help')                                       && &bt == 'help'))) || (exists('g:signify_skip_filename') && has_key(g:signify_skip_filename, b:sy_path))
                                return
                              endif
                            
                              " new buffer.. add to list of registered files
    2              0.000028   if !exists('b:sy') || b:sy.path != b:sy_path
                                let b:sy = { 'path'  : b:sy_path, 'buffer': bufnr(''), 'active': 0, 'type'  : 'unknown', 'hunks' : [], 'id_top': g:id_top, 'stats' : [-1, -1, -1] }
                                if get(g:, 'signify_disable_by_default')
                                  return
                                endif
                            
                                " register buffer as active
                                let b:sy.active = 1
                            
                                let [ diff, b:sy.type ] = sy#repo#detect()
                                if b:sy.type == 'unknown'
                                  return
                                endif
                            
                                " register file as active with found VCS
                                let b:sy.stats = [0, 0, 0]
                            
                                let dir = fnamemodify(b:sy.path, ':h')
                                if !has_key(g:sy_cache, dir)
                                  let g:sy_cache[dir] = b:sy.type
                                endif
                            
                                if empty(diff)
                                  " no changes found
                                  return
                                endif
                            
                              " inactive buffer.. bail out
                              elseif !b:sy.active
                                return
                            
                              " retry detecting VCS
                              elseif b:sy.type == 'unknown'
    2   1.132563   0.000105     let [ diff, b:sy.type ] = sy#repo#detect()
    2              0.000024     if b:sy.type == 'unknown'
                                  " no VCS found
    2              0.000006       return
                                endif
                            
                              " update signs
                              else
                                let diff = sy#repo#get_diff_{b:sy.type}()[1]
                                let b:sy.id_top = g:id_top
                              endif
                            
                              if get(g:, 'signify_line_highlight')
                                call sy#highlight#line_enable()
                              else
                                call sy#highlight#line_disable()
                              endif
                            
                              call sy#sign#process_diff(diff)
                            
                              let b:sy.id_top = (g:id_top - 1)

FUNCTION  sy#repo#get_diff_git()
Called 2 times
Total time:   0.054922
 Self time:   0.000251

count  total (s)   self (s)
    2              0.000041   let diffoptions = has_key(g:signify_diffoptions, 'git') ? g:signify_diffoptions.git : ''
    2   0.054831   0.000160   let diff = sy#util#run_in_dir(fnamemodify(b:sy.path, ':h'), 'git diff --no-color --no-ext-diff -U0 '. diffoptions .' -- '. sy#util#escape(fnamemodify(b:sy.path, ':t')))
                            
    2              0.000033   return v:shell_error ? [0, ''] : [1, diff]

FUNCTION  syntastic#util#var()
Called 32 times
Total time:   0.000727
 Self time:   0.000727

count  total (s)   self (s)
   32              0.000674     return exists('b:syntastic_' . a:name) ? b:syntastic_{a:name} : exists('g:syntastic_' . a:name) ? g:syntastic_{a:name} : a:0 > 0 ? a:1 : ''

FUNCTION  syntastic#util#compareLexi()
Called 4 times
Total time:   0.000201
 Self time:   0.000201

count  total (s)   self (s)
    4              0.000061     for idx in range(max([len(a:a), len(a:b)]))
    4              0.000039         let a_element = str2nr(get(a:a, idx, 0))
    4              0.000046         let b_element = str2nr(get(a:b, idx, 0))
    4              0.000017         if a_element != b_element
    4              0.000017             return a_element > b_element ? 1 : -1
                                    endif
                                endfor
                                " Everything matched, so it is at least the required version.
                                return 0

FUNCTION  <SNR>159_ProcessFile()
Called 2 times
Total time:   0.068899
 Self time:   0.004322

count  total (s)   self (s)
    2   0.000051   0.000023     call s:debug('ProcessFile called [' . a:fname . ']')
                            
    2   0.000325   0.000020     if !s:IsValidFile(a:fname, a:ftype)
                                    call s:debug('Not a valid file, returning')
                                    return
                                endif
                            
    2              0.000021     let typeinfo = s:known_types[a:ftype]
                            
                                " If the file has only been updated preserve the fold states, otherwise
                                " create a new entry
    2   0.000069   0.000037     if s:known_files.has(a:fname) && !empty(s:known_files.get(a:fname))
    2   0.000035   0.000020         let fileinfo = s:known_files.get(a:fname)
    2              0.000010         let typeinfo = fileinfo.typeinfo
    2   0.000501   0.000028         call fileinfo.reset()
    2              0.000003     else
                                    if exists('#TagbarProjects#User')
                                        execute 'doautocmd <nomodeline> TagbarProjects User ' . a:fname
                                        if exists('b:tagbar_type')
                                            let typeinfo = extend(copy(typeinfo), s:TransformUserTypeDef(b:tagbar_type))
                                            call typeinfo.createKinddict()
                                        endif
                                    endif
                                    let fileinfo = s:FileInfo.New(a:fname, a:ftype, typeinfo)
                                endif
                            
    2   0.000242   0.000211     call s:debug('typeinfo for file to process: ' . string(typeinfo))
                            
                                " Use a temporary files for ctags processing instead of the original one.
                                " This allows using Tagbar for files accessed with netrw, and also doesn't
                                " slow down Tagbar for files that sit on slow network drives.
    2              0.000017     let tempfile = tempname()
    2              0.000019     let ext = fnamemodify(fileinfo.fpath, ':e')
    2              0.000008     if ext != ''
    2              0.000013         let tempfile .= '.' . ext
    2              0.000002     endif
                            
    2              0.000490     call writefile(getbufline(fileinfo.bufnr, 1, '$'), tempfile)
    2              0.000036     let fileinfo.mtime = getftime(tempfile)
                            
    2   0.056008   0.000108     let ctags_output = s:ExecuteCtagsOnFile(tempfile, a:fname, typeinfo)
                            
    2              0.000037     call delete(tempfile)
                            
    2              0.000011     if ctags_output == -1
                                    call s:debug('Ctags error when processing file')
                                    " Put an empty entry into known_files so the error message is only
                                    " shown once
                                    call s:known_files.put({}, a:fname)
                                    return
                                elseif ctags_output == ''
                                    call s:debug('Ctags output empty')
                                    " No need to go through the tag processing if there are no tags, and
                                    " preserving the old fold state isn't necessary either
                                    call s:known_files.put(s:FileInfo.New(a:fname, a:ftype, s:known_types[a:ftype]), a:fname)
                                    return
                                endif
                            
    2   0.000099   0.000066     call s:debug('Filetype tag kinds: ' . string(keys(typeinfo.kinddict)))
                            
                                " Parse the ctags output lines
    2   0.000047   0.000019     call s:debug('Parsing ctags output')
    2              0.000073     let rawtaglist = split(ctags_output, '\n\+')
   10              0.000031     for line in rawtaglist
                                    " skip comments
    8              0.000090         if line =~# '^!_TAG_'
                                        continue
                                    endif
                            
    8              0.000103         let parts = split(line, ';"')
    8              0.000042         if len(parts) == 2 " Is a valid tag line
    8   0.005682   0.000230             let taginfo = s:ParseTagline(parts[0], parts[1], typeinfo, fileinfo)
    8              0.000071             let fileinfo.fline[taginfo.fields.line] = taginfo
    8              0.000093             call add(fileinfo.tags, taginfo)
    8              0.000013         endif
    8              0.000011     endfor
                            
                                " Process scoped tags
    2              0.000010     let processedtags = []
    2              0.000009     if has_key(typeinfo, 'kind2scope')
    2   0.000058   0.000025         call s:debug('Processing scoped tags')
                            
    2              0.000009         let scopedtags = []
    2              0.000012         let is_scoped = 'has_key(typeinfo.kind2scope, v:val.fields.kind) || has_key(v:val, "scope")'
    2              0.000109         let scopedtags += filter(copy(fileinfo.tags), is_scoped)
    2              0.000080         call filter(fileinfo.tags, '!(' . is_scoped . ')')
                            
    2   0.000561   0.000065         call s:AddScopedTags(scopedtags, processedtags, {}, 0, typeinfo, fileinfo, line('$'))
                            
    2              0.000008         if !empty(scopedtags)
                                        echoerr 'Tagbar: ''scopedtags'' not empty after processing,' 'this should never happen!' 'Please contact the script maintainer with an example.'
                                    endif
    2              0.000003     endif
    2   0.000061   0.000031     call s:debug('Number of top-level tags: ' . len(processedtags))
                            
                                " Create a placeholder tag for the 'kind' header for folding purposes
   26              0.000069     for kind in typeinfo.kinds
                            
   24              0.000633         let curtags = filter(copy(fileinfo.tags), 'v:val.fields.kind ==# kind.short')
   24   0.000698   0.000362         call s:debug('Processing kind: ' . kind.short . ', number of tags: ' . len(curtags))
                            
   24              0.000091         if empty(curtags)
   22              0.000065             continue
                                    endif
                            
    2   0.000216   0.000035         let kindtag          = s:KindheaderTag.New(kind.long)
    2              0.000013         let kindtag.short    = kind.short
    2              0.000012         let kindtag.numtags  = len(curtags)
    2              0.000009         let kindtag.fileinfo = fileinfo
                            
   10              0.000020         for tag in curtags
    8              0.000026             let tag.parent = kindtag
    8              0.000015         endfor
    2              0.000004     endfor
                            
    2              0.000009     if !empty(processedtags)
                                    call extend(fileinfo.tags, processedtags)
                                endif
                            
                                " Clear old folding information from previous file version to prevent leaks
    2   0.000070   0.000030     call fileinfo.clearOldFolds()
                            
                                " Sort the tags
    2              0.000015     let s:compare_typeinfo = typeinfo
    2   0.001138   0.000021     call fileinfo.sortTags()
                            
    2   0.000075   0.000028     call s:known_files.put(fileinfo)

FUNCTION  <SNR>159_AddScopedTags()
Called 2 times
Total time:   0.000496
 Self time:   0.000496

count  total (s)   self (s)
    2              0.000013     if !empty(a:parent)
                                    let curpath = a:parent.fullpath
                                    let pscope  = a:typeinfo.kind2scope[a:parent.fields.kind]
                                else
    2              0.000007         let curpath = ''
    2              0.000006         let pscope  = ''
    2              0.000004     endif
                            
    2              0.000008     let is_cur_tag = 'v:val.depth == a:depth'
                            
    2              0.000008     if !empty(curpath)
                                    " Check whether the tag is either a direct child at the current depth
                                    " or at least a proper grandchild with pseudo-tags in between. If it
                                    " is a direct child also check for matching scope.
                                    let is_cur_tag .= ' && (v:val.path ==# curpath || match(v:val.path, ''\V\^\C'' . curpath . a:typeinfo.sro) == 0) && (v:val.path ==# curpath ? (v:val.scope ==# pscope) : 1) && v:val.fields.line >= a:parent.fields.line && v:val.fields.line <= a:maxline'
                                endif
                            
    2              0.000024     let curtags = filter(copy(a:tags), is_cur_tag)
                            
    2              0.000007     if !empty(curtags)
                                    call filter(a:tags, '!(' . is_cur_tag . ')')
                            
                                    let realtags   = []
                                    let pseudotags = []
                            
                                    while !empty(curtags)
                                        let tag = remove(curtags, 0)
                            
                                        if tag.path != curpath
                                            " tag is child of a pseudo-tag, so create a new pseudo-tag and
                                            " add all its children to it
                                            let pseudotag = s:ProcessPseudoTag(curtags, tag, a:parent, a:typeinfo, a:fileinfo)
                            
                                            call add(pseudotags, pseudotag)
                                        else
                                            call add(realtags, tag)
                                        endif
                                    endwhile
                            
                                    " Recursively add the children of the tags on the current level
                                    for tag in realtags
                                        let tag.parent = a:parent
                            
                                        if !has_key(a:typeinfo.kind2scope, tag.fields.kind)
                                            continue
                                        endif
                            
                                        if !has_key(tag, 'children')
                                            let tag.children = []
                                        endif
                            
                                        " Check for tags with the exact same name that may be created
                                        " alternatively in a conditional (Issue #139). The only way to
                                        " distinguish between them is by line number.
                                        let twins = filter(copy(realtags), "v:val.fullpath ==# '" . substitute(tag.fullpath, "'", "''", 'g') . "'" . " && v:val.fields.line != " . tag.fields.line)
                                        let maxline = line('$')
                                        for twin in twins
                                            if twin.fields.line <= maxline && twin.fields.line > tag.fields.line
                                                let maxline = twin.fields.line - 1
                                            endif
                                        endfor
                            
                                        call s:AddScopedTags(a:tags, tag.children, tag, a:depth + 1, a:typeinfo, a:fileinfo, maxline)
                                    endfor
                                    call extend(a:processedtags, realtags)
                            
                                    " Recursively add the children of the tags that are children of the
                                    " pseudo-tags on the current level
                                    for tag in pseudotags
                                        call s:ProcessPseudoChildren(a:tags, tag, a:depth, a:typeinfo, a:fileinfo)
                                    endfor
                                    call extend(a:processedtags, pseudotags)
                                endif
                            
                                " Now we have to check if there are any pseudo-tags at the current level
                                " so we have to check for real tags at a lower level, i.e. grandchildren
    2              0.000009     let is_grandchild = 'v:val.depth > a:depth'
                            
    2              0.000008     if !empty(curpath)
                                    let is_grandchild .= ' && match(v:val.path, ''\V\^\C'' . curpath . a:typeinfo.sro) == 0'
                                endif
                            
    2              0.000024     let grandchildren = filter(copy(a:tags), is_grandchild)
                            
    2              0.000008     if !empty(grandchildren)
                                    call s:AddScopedTags(a:tags, a:processedtags, a:parent, a:depth + 1, a:typeinfo, a:fileinfo, a:maxline)
                                endif

FUNCTION  airline#parts#ffenc()
Called 56 times
Total time:   0.003550
 Self time:   0.003550

count  total (s)   self (s)
   56              0.003445   return printf('%s%s', &fenc, strlen(&ff) > 0 ? '['.&ff.']' : '')

FUNCTION  sy#util#escape()
Called 8 times
Total time:   0.000567
 Self time:   0.000567

count  total (s)   self (s)
    8              0.000089   if exists('+shellslash')
                                let old_ssl = &shellslash
                                if fnamemodify(&shell, ':t') == 'cmd.exe'
                                  set noshellslash
                                else
                                  set shellslash
                                endif
                              endif
                            
    8              0.000116   let path = shellescape(a:path)
                            
    8              0.000051   if exists('old_ssl')
                                let &shellslash = old_ssl
                              endif
                            
    8              0.000032   return path

FUNCTION  tagbar#currenttag()
Called 10 times
Total time:   0.005920
 Self time:   0.001692

count  total (s)   self (s)
                                " Indicate that the statusline functionality is being used. This prevents
                                " the CloseWindow() function from removing the autocommands.
   10              0.000084     let s:statusline_in_use = 1
                            
   10              0.000042     if a:0 > 0
                                    " also test for non-zero value for backwards compatibility
   10              0.000245         let longsig   = a:1 =~# 's' || (type(a:1) == type(0) && a:1 != 0)
   10              0.000118         let fullpath  = a:1 =~# 'f'
   10              0.000100         let prototype = a:1 =~# 'p'
   10              0.000026     else
                                    let longsig   = 0
                                    let fullpath  = 0
                                    let prototype = 0
                                endif
                            
   10   0.001063   0.000167     if !s:Init(1)
                                    return a:default
                                endif
                            
   10   0.002905   0.000184     let tag = s:GetNearbyTag(0, 1)
                            
   10              0.000062     if !empty(tag)
   10              0.000036         if prototype
                                        return tag.getPrototype(1)
                                    else
   10   0.000853   0.000242             return printf(a:fmt, tag.str(longsig, fullpath))
                                    endif
                                else
                                    return a:default
                                endif

FUNCTION  <SNR>91__normaliseFiletype()
Called 2 times
Total time:   0.000115
 Self time:   0.000115

count  total (s)   self (s)
    2              0.000038     let ft = get(s:defaultFiletypeMap, a:ftalias, a:ftalias)
    2              0.000024     let ft = get(g:syntastic_filetype_map, ft, ft)
    2              0.000037     let ft = substitute(ft, '\m-', '_', 'g')
    2              0.000009     return ft

FUNCTION  UndotreeUpdate()
Called 52 times
Total time:   0.001648
 Self time:   0.001648

count  total (s)   self (s)
   52              0.001055     if !exists('t:undotree')
   52              0.000295         return
                                endif
                                if !exists('w:undotree_id')
                                    let w:undotree_id = 'id_'.s:getUniqueID()
                                    call s:log("Unique window id assigned: ".w:undotree_id)
                                endif
                                " assume window layout won't change during updating.
                                let thiswinnr = winnr()
                                call t:undotree.Update()
                                " focus moved
                                if winnr() != thiswinnr
                                    call s:exec("norm! ".thiswinnr."\<c-w>\<c-w>")
                                endif

FUNCTION  328()
Called 4 times
Total time:   0.000516
 Self time:   0.000179

count  total (s)   self (s)
    4   0.000506   0.000169     return syntastic#util#unique(map(copy(self._rawLoclist), 'str2nr(v:val["bufnr"])') + [self._owner])

FUNCTION  airline#parts#paste()
Called 56 times
Total time:   0.000644
 Self time:   0.000644

count  total (s)   self (s)
   56              0.000530   return g:airline_detect_paste && &paste ? g:airline_symbols.paste : ''

FUNCTION  <SNR>210__regHandler()
Called 14 times
Total time:   0.000689
 Self time:   0.000689

count  total (s)   self (s)
   14              0.000090     let handler = {}
   14              0.000109     let handler["regex"] = a:regex
   14              0.000199     let handler["func"] = function(a:function)
   14              0.000095     let handler["args"] = a:args
   14              0.000146     call add(s:handlers, handler)

FUNCTION  airline#parts#readonly()
Called 56 times
Total time:   0.000547
 Self time:   0.000547

count  total (s)   self (s)
   56              0.000456   return &readonly ? g:airline_symbols.readonly : ''

FUNCTION  airline#extensions#syntastic#get_warnings()
Called 56 times
Total time:   0.013698
 Self time:   0.001874

count  total (s)   self (s)
   56   0.012652   0.000828   let errors = SyntasticStatuslineFlag()
   56              0.000411   if strlen(errors) > 0
                                return errors.(g:airline_symbols.space)
                              endif
   56              0.000127   return ''

FUNCTION  <SNR>93_BufWritePostHook()
Called 2 times
Total time:   1.227680
 Self time:   0.000222

count  total (s)   self (s)
    2   0.000220   0.000119     call syntastic#log#debug(g:SyntasticDebugAutocommands, 'autocmd: BufWritePost, buffer ' . bufnr("") . ' = ' . string(bufname(str2nr(bufnr("")))))
    2   1.227446   0.000089     call s:UpdateErrors(1)

FUNCTION  StripTrailingWhitespace()
Called 2 times
Total time:   0.000640
 Self time:   0.000640

count  total (s)   self (s)
                                    " Preparation: save last search, and cursor position.
    2              0.000022         let _s=@/
    2              0.000020         let l = line(".")
    2              0.000016         let c = col(".")
                                    " do the business:
    2              0.000517         %s/\s\+$//e
                                    " clean up: restore previous search history, and cursor position
    2              0.000019         let @/=_s
    2              0.000019         call cursor(l, c)

FUNCTION  MakeViewCheck()
Called 2 times
Total time:   0.000419
 Self time:   0.000419

count  total (s)   self (s)
    2              0.000022     if &buftype != '' | return 0 | endif
    2              0.000037     if expand('%') =~ '\[.*\]' | return 0 | endif
    2              0.000103     if empty(glob(expand('%:p'))) | return 0 | endif
    2              0.000016     if &modifiable == 0 | return 0 | endif
    2              0.000038     if len($TEMP) && expand('%:p:h') == $TEMP | return 0 | endif
    2              0.000023     if len($TMP) && expand('%:p:h') == $TMP | return 0 | endif
                            
    2              0.000040     let file_name = expand('%:p')
    4              0.000031     for ifiles in g:skipview_files
    2              0.000038         if file_name =~ ifiles
                                        return 0
                                    endif
    2              0.000006     endfor
                            
    2              0.000007     return 1

FUNCTION  SyntaxCheckers_cpp_gcc_GetLocList()
Called 2 times
Total time:   1.140311
 Self time:   0.001067

count  total (s)   self (s)
    2   1.140308   0.001064     return syntastic#c#GetLocList('cpp', 'gcc', { 'errorformat':     '%-G%f:%s:,' .     '%f:%l:%c: %trror: %m,' .     '%f:%l:%c: %tarning: %m,' .     '%f:%l:%c: %m,'.     '%f:%l: %trror: %m,'.     '%f:%l: %tarning: %m,'.     '%f:%l: %m', 'main_flags': '-x c++ -fsyntax-only', 'header_flags': '-x c++', 'header_names': '\m\.\(h\|hpp\|hh\)$' })

FUNCTION  <SNR>210__getIncludeDirs()
Called 2 times
Total time:   0.001054
 Self time:   0.000371

count  total (s)   self (s)
    2              0.000013     let include_dirs = []
                            
    2              0.000080     if a:filetype =~# '\v^%(c|cpp|objc|objcpp)$' && (!exists('g:syntastic_'.a:filetype.'_no_default_include_dirs') || !g:syntastic_{a:filetype}_no_default_include_dirs)
    2              0.000026         let include_dirs = copy(s:default_includes)
    2              0.000005     endif
                            
    2              0.000017     if exists('g:syntastic_'.a:filetype.'_include_dirs')
                                    call extend(include_dirs, g:syntastic_{a:filetype}_include_dirs)
                                endif
                            
    2   0.000885   0.000202     return join(map(syntastic#util#unique(include_dirs), 'syntastic#util#shescape("-I" . v:val)'))

FUNCTION  <SNR>142_get_hunks_signify()
Called 56 times
Total time:   0.003380
 Self time:   0.001869

count  total (s)   self (s)
   56   0.002346   0.000835   let hunks = sy#repo#get_stats()
   56              0.000399   if hunks[0] >= 0
                                return hunks
                              endif
   56              0.000157   return []

FUNCTION  <SNR>93_resolveFiletypes()
Called 2 times
Total time:   0.000081
 Self time:   0.000081

count  total (s)   self (s)
    2              0.000024     let type = a:0 ? a:1 : &filetype
    2              0.000052     return split( get(g:syntastic_filetype_map, type, type), '\m\.' )

FUNCTION  sy#repo#get_diff_svn()
Called 2 times
Total time:   0.226279
 Self time:   0.000574

count  total (s)   self (s)
    2              0.000038   let diffoptions = has_key(g:signify_diffoptions, 'svn') ? g:signify_diffoptions.svn : ''
    2   0.226145   0.000440   let diff = system('svn diff --diff-cmd '. s:difftool .' -x -U0 '. diffoptions .' -- '. sy#util#escape(b:sy.path))
                            
    2              0.000066   return v:shell_error ? [0, ''] : [1, diff]

FUNCTION  <SNR>142_get_hunks()
Called 56 times
Total time:   0.006778
 Self time:   0.003398

count  total (s)   self (s)
   56              0.000445   if empty(s:source_func)
                                if get(g:, 'loaded_signify', 0)
                                  let s:source_func = 's:get_hunks_signify'
                                elseif exists('*GitGutterGetHunkSummary')
                                  let s:source_func = 's:get_hunks_gitgutter'
                                elseif exists('*changes#GetStats')
                                  let s:source_func = 's:get_hunks_changes'
                                else
                                  let s:source_func = 's:get_hunks_empty'
                                endif
                              endif
   56   0.004411   0.001031   return {s:source_func}()

FUNCTION  sy#repo#get_diff_hg()
Called 2 times
Total time:   0.308518
 Self time:   0.000565

count  total (s)   self (s)
    2              0.000053   let diffoptions = has_key(g:signify_diffoptions, 'hg') ? g:signify_diffoptions.hg : ''
    2   0.308378   0.000425   let diff = system('hg diff --nodates -U0 '. diffoptions .' -- '. sy#util#escape(b:sy.path))
                            
    2              0.000060   return v:shell_error ? [0, ''] : [1, diff]

FUNCTION  403()
Called 10 times
Total time:   0.000611
 Self time:   0.000611

count  total (s)   self (s)
   10              0.000058     if a:full && self.path != ''
                                    let str = self.path . self.typeinfo.sro . self.name
                                else
   10              0.000057         let str = self.name
   10              0.000021     endif
                            
   10              0.000075     if has_key(self.fields, 'signature')
   10              0.000034         if a:longsig
                                        let str .= self.fields.signature
                                    else
   10              0.000062             let str .= '()'
   10              0.000019         endif
   10              0.000017     endif
                            
   10              0.000030     return str

FUNCTION  syntastic#c#GetLocList()
Called 2 times
Total time:   1.137014
 Self time:   0.000349

count  total (s)   self (s)
    2              0.000009     try
    2   0.006218   0.000051         let flags = s:_getCflags(a:filetype, a:subchecker, a:options)
    2              0.000008     catch /\m\C^Syntastic: skip checks$/
                                    return []
                                endtry
                            
    2   0.000280   0.000076     let makeprg = syntastic#util#shexpand(g:syntastic_{a:filetype}_compiler) . ' ' . flags . ' ' . syntastic#util#shexpand('%')
                            
    2   0.000138   0.000047     let errorformat = s:_getCheckerVar('g', a:filetype, a:subchecker, 'errorformat', a:options['errorformat'])
                            
    2   0.000121   0.000038     let postprocess = s:_getCheckerVar('g', a:filetype, a:subchecker, 'remove_include_errors', 0) ? ['filterForeignErrors'] : []
                            
                                " process makeprg
    2   1.130204   0.000084     return SyntasticMake({ 'makeprg': makeprg, 'errorformat': errorformat, 'postprocess': postprocess })

FUNCTION  airline#extensions#tagbar#currenttag()
Called 56 times
Total time:   0.008419
 Self time:   0.002499

count  total (s)   self (s)
   56              0.000499   if get(w:, 'airline_active', 0)
   56              0.000452     if s:airline_tagbar_last_lookup_time != localtime()
   10   0.006160   0.000240       let s:airline_tagbar_last_lookup_val = tagbar#currenttag('%s', '', s:flags)
   10              0.000103       let s:airline_tagbar_last_lookup_time = localtime()
   10              0.000019     endif
   56              0.000314     return s:airline_tagbar_last_lookup_val
                              endif
                              return ''

FUNCTION  <SNR>93_skipFile()
Called 4 times
Total time:   0.000904
 Self time:   0.000628

count  total (s)   self (s)
    4              0.000057     let fname = expand('%')
    4   0.000750   0.000474     let skip = get(b:, 'syntastic_skip_checks', 0) || (&buftype != '') || !filereadable(fname) || getwinvar(0, '&diff') || s:ignoreFile(fname) || fnamemodify(fname, ':e') =~? g:syntastic_ignore_extensions
    4              0.000023     if skip
                                    call syntastic#log#debug(g:SyntasticDebugTrace, 'skipFile: skipping')
                                endif
    4              0.000014     return skip

FUNCTION  415()
Called 10 times
Total time:   0.000225
 Self time:   0.000225

count  total (s)   self (s)
   10              0.000117     let idx = self.kinddict[a:kind]
   10              0.000079     return self.kinds[idx]

FUNCTION  418()
Called 2 times
Total time:   0.000473
 Self time:   0.000473

count  total (s)   self (s)
    2              0.000030     let self.mtime = getftime(self.fpath)
    2              0.000033     let self.tags  = []
    2              0.000123     let self.fline = {}
    2              0.000008     let self.tline = {}
                            
    2              0.000011     let self._tagfolds_old = self.tagfolds
    2              0.000006     let self.tagfolds = {}
                            
   26              0.000064     for kind in self.typeinfo.kinds
   24              0.000111         let self.tagfolds[kind.short] = {}
   24              0.000051     endfor

FUNCTION  <SNR>159_Init()
Called 10 times
Total time:   0.000896
 Self time:   0.000896

count  total (s)   self (s)
   10              0.000068     if s:checked_ctags == 2 && a:silent
                                    return 0
                                elseif s:checked_ctags != 1
                                    if !s:CheckForExCtags(a:silent)
                                        return 0
                                    endif
                                endif
                            
   10              0.000045     if !s:checked_ctags_types
                                    call s:GetSupportedFiletypes()
                                endif
                            
   10              0.000037     if !s:type_init_done
                                    call s:InitTypes()
                                endif
                            
   10              0.000038     if !s:autocommands_done
                                    call s:CreateAutocommands()
                                    call s:AutoUpdate(fnamemodify(expand('%'), ':p'), 0)
                                endif
                            
   10              0.000025     return 1

FUNCTION  <SNR>210__getCheckerVar()
Called 14 times
Total time:   0.000629
 Self time:   0.000629

count  total (s)   self (s)
   14              0.000109     let prefix = a:scope . ':' . 'syntastic_'
   14              0.000180     if exists(prefix . a:filetype . '_' . a:subchecker . '_' . a:name)
                                    return {a:scope}:syntastic_{a:filetype}_{a:subchecker}_{a:name}
                                elseif exists(prefix . a:filetype . '_' . a:name)
    2              0.000028         return {a:scope}:syntastic_{a:filetype}_{a:name}
                                else
   12              0.000033         return a:default
                                endif

FUNCTION  420()
Called 2 times
Total time:   0.001117
 Self time:   0.000073

count  total (s)   self (s)
    2              0.000017     if get(s:compare_typeinfo, 'sort', g:tagbar_sort)
    2   0.001079   0.000035         call s:SortTags(self.tags, 's:CompareByKind')
    2              0.000003     else
                                    call s:SortTags(self.tags, 's:CompareByLine')
                                endif

FUNCTION  361()
Called 2 times
Total time:   0.069026
 Self time:   0.000283

count  total (s)   self (s)
    2   0.000169   0.000054     let ft = s:_normaliseFiletype(a:ftalias)
    2   0.068526   0.000034     call self._loadCheckersFor(ft)
                            
    2              0.000015     let checkers_map = self._checkerMap[ft]
    2              0.000011     if empty(checkers_map)
                                    return []
                                endif
                            
    2   0.000089   0.000032     call self._checkDeprecation(ft)
                            
    2              0.000058     let names = !empty(a:hints_list) ? syntastic#util#unique(a:hints_list) : exists('b:syntastic_checkers') ? b:syntastic_checkers : exists('g:syntastic_' . ft . '_checkers') ? g:syntastic_{ft}_checkers : get(s:defaultCheckers, ft, 0)
                            
    2   0.000130   0.000051     return type(names) == type([]) ? self._filterCheckersByName(checkers_map, names) : [checkers_map[keys(checkers_map)[0]]]

FUNCTION  423()
Called 12 times
Total time:   0.000143
 Self time:   0.000143

count  total (s)   self (s)
   12              0.000064     if !s:paused || a:forcecurrent
   12              0.000050         return self._current
                                else
                                    return self._paused
                                endif

FUNCTION  424()
Called 2 times
Total time:   0.000015
 Self time:   0.000015

count  total (s)   self (s)
    2              0.000012     let self._current = a:fileinfo

FUNCTION  426()
Called 8 times
Total time:   0.000072
 Self time:   0.000072

count  total (s)   self (s)
    8              0.000063     return get(self._files, a:fname, {})

FUNCTION  427()
Called 2 times
Total time:   0.000047
 Self time:   0.000047

count  total (s)   self (s)
    2              0.000008     if a:0 == 1
                                    let self._files[a:1] = a:fileinfo
                                else
    2              0.000009         let fname = a:fileinfo.fpath
    2              0.000013         let self._files[fname] = a:fileinfo
    2              0.000002     endif

FUNCTION  428()
Called 12 times
Total time:   0.000110
 Self time:   0.000110

count  total (s)   self (s)
   12              0.000093     return has_key(self._files, a:fname)

FUNCTION  airline#extensions#branch#head()
Called 56 times
Total time:   0.015717
 Self time:   0.013792

count  total (s)   self (s)
   56              0.000774   if exists('b:airline_head') && !empty(b:airline_head)
                                return b:airline_head
                              endif
                            
   56              0.000309   let b:airline_head = ''
   56              0.000315   let found_fugitive_head = 0
                            
   56              0.000539   if s:has_fugitive && !exists('b:mercurial_dir')
   56   0.001548   0.000880     let b:airline_head = fugitive#head(7)
   56              0.000280     let found_fugitive_head = 1
                            
   56              0.000544     if empty(b:airline_head) && !exists('b:git_dir')
   56   0.004320   0.003063       let b:airline_head = s:get_git_branch(expand("%:p:h"))
   56              0.000138     endif
   56              0.000095   endif
                            
   56              0.000315   if empty(b:airline_head)
   56              0.000229     if s:has_lawrencium
                                  let b:airline_head = lawrencium#statusline()
                                endif
   56              0.000082   endif
                            
   56              0.000253   if empty(b:airline_head)
   56              0.000186     if s:has_vcscommand
                                  call VCSCommandEnableBufferSetup()
                                  if exists('b:VCSCommandBufferInfo')
                                    let b:airline_head = get(b:VCSCommandBufferInfo, 0, '')
                                  endif
                                endif
   56              0.000078   endif
                            
   56              0.000569   if empty(b:airline_head) || !found_fugitive_head && !s:check_in_path()
   56              0.000307     let b:airline_head = ''
   56              0.000108   endif
                            
   56              0.000529   if exists("g:airline#extensions#branch#displayed_head_limit")
                                let w:displayed_head_limit = g:airline#extensions#branch#displayed_head_limit
                                if len(b:airline_head) > w:displayed_head_limit - 1
                                  let b:airline_head = b:airline_head[0:w:displayed_head_limit - 1].'…'
                                endif
                              endif
                            
   56              0.000216   return b:airline_head

FUNCTION  syntastic#log#debugDump()
Called 2 times
Total time:   0.000070
 Self time:   0.000049

count  total (s)   self (s)
    2   0.000049   0.000028     if !s:isDebugEnabled(a:level)
    2              0.000003         return
                                endif
                            
                                call syntastic#log#debugShowVariables( a:level, sort(keys(g:syntastic_defaults)) )

FUNCTION  SyntaxCheckers_cpp_gcc_IsAvailable()
Called 1 time
Total time:   0.000498
 Self time:   0.000256

count  total (s)   self (s)
    1              0.000009     if !exists('g:syntastic_cpp_compiler')
    1   0.000306   0.000158         let g:syntastic_cpp_compiler = executable(self.getExec()) ? self.getExec() : 'clang++'
    1              0.000003     endif
    1   0.000122   0.000028     call self.log('g:syntastic_cpp_compiler =', g:syntastic_cpp_compiler)
    1              0.000052     return executable(expand(g:syntastic_cpp_compiler))

FUNCTION  airline#parts#mode()
Called 56 times
Total time:   0.000721
 Self time:   0.000721

count  total (s)   self (s)
   56              0.000606   return get(w:, 'airline_current_mode', '')

FUNCTION  sy#repo#get_stats()
Called 56 times
Total time:   0.001511
 Self time:   0.001511

count  total (s)   self (s)
   56              0.000749   if !exists('b:sy') || !has_key(b:sy, 'stats')
                                return [-1, -1, -1]
                              endif
                            
   56              0.000249   return b:sy.stats

FUNCTION  <SNR>159_IsValidFile()
Called 4 times
Total time:   0.000603
 Self time:   0.000557

count  total (s)   self (s)
    4   0.000128   0.000082     call s:debug('Checking if file is valid [' . a:fname . ']')
                            
    4              0.000022     if a:fname == '' || a:ftype == ''
                                    call s:debug('Empty filename or type')
                                    return 0
                                endif
                            
    4              0.000089     if !filereadable(a:fname) && getbufvar(a:fname, 'netrw_tmpfile') == ''
                                    call s:debug('File not readable')
                                    return 0
                                endif
                            
    4              0.000096     if getbufvar(a:fname, 'tagbar_ignore') == 1
                                    call s:debug('File is marked as ignored')
                                    return 0
                                endif
                            
    4              0.000009     if &previewwindow
                                    call s:debug('In preview window')
                                    return 0
                                endif
                            
    4              0.000029     if !has_key(s:known_types, a:ftype)
                                    if exists('g:tagbar_type_' . a:ftype)
                                        " Filetype definition must have been specified in an 'ftplugin'
                                        " file, so load it now
                                        call s:LoadUserTypeDefs(a:ftype)
                                    else
                                        call s:debug('Unsupported filetype: ' . a:ftype)
                                        return 0
                                    endif
                                endif
                            
    4              0.000007     return 1

FUNCTION  syntastic#c#ReadConfig()
Called 2 times
Total time:   0.000709
 Self time:   0.000709

count  total (s)   self (s)
                                " search in the current file's directory upwards
    2              0.000670     let config = findfile(a:file, '.;')
    2              0.000022     if config == '' || !filereadable(config)
    2              0.000007         return ''
                                endif
                            
                                " convert filename into absolute path
                                let filepath = fnamemodify(config, ':p:h')
                            
                                " try to read config file
                                try
                                    let lines = readfile(config)
                                catch /\m^Vim\%((\a\+)\)\=:E48[45]/
                                    return ''
                                endtry
                            
                                " filter out empty lines and comments
                                call filter(lines, 'v:val !~ ''\v^(\s*#|$)''')
                            
                                " remove leading and trailing spaces
                                call map(lines, 'substitute(v:val, ''\m^\s\+'', "", "")')
                                call map(lines, 'substitute(v:val, ''\m\s\+$'', "", "")')
                            
                                let parameters = []
                                for line in lines
                                    let matches = matchstr(line, '\m\C^\s*-I\s*\zs.\+')
                                    if matches != ''
                                        " this one looks like an absolute path
                                        if match(matches, '\m^\%(/\|\a:\)') != -1
                                            call add(parameters, '-I' . matches)
                                        else
                                            call add(parameters, '-I' . filepath . syntastic#util#Slash() . matches)
                                        endif
                                    else
                                        call add(parameters, line)
                                    endif
                                endfor
                            
                                return join(map(parameters, 'syntastic#util#shescape(v:val)'))

FUNCTION  <SNR>159_EscapeCtagsCmd()
Called 2 times
Total time:   0.001213
 Self time:   0.001090

count  total (s)   self (s)
    2   0.000053   0.000024     call s:debug('EscapeCtagsCmd called')
    2   0.000050   0.000024     call s:debug('ctags_bin: ' . a:ctags_bin)
    2              0.000014     if type(a:args)==type('')
                                    call s:debug('ctags_args (is a string): ' . a:args)
                                elseif type(a:args)==type([])
    2   0.000338   0.000301         call s:debug('ctags_args (is a list): ' . string(a:args))
    2              0.000003     endif
                            
    2              0.000012     if exists('+shellslash')
                                    let shellslash_save = &shellslash
                                    set noshellslash
                                endif
                            
                                "Set up 0th argument of ctags_cmd
                                "a:ctags_bin may have special characters that require escaping.
    2              0.000030     if &shell =~ 'cmd\.exe$' && a:ctags_bin !~ '\s'
                                    "For windows cmd.exe, escaping the 0th argument can cause
                                    "problems if it references a batch file and the batch file uses %~dp0.
                                    "So for windows cmd.exe, only escape the 0th argument iff necessary.
                                    "Only known necessary case is when ctags_bin executable filename has
                                    "whitespace character(s).
                            
                                    "  Example: If 0th argument is wrapped in double quotes AND it is not
                                    "  an absolute path to ctags_bin, but rather an executable in %PATH%,
                                    "  then %~dp0 resolves to the current working directory rather than
                                    "  the batch file's directory. Batch files like this generally exepect
                                    "  and depend on %~dp0 to resolve the batch file's directory.
                                    "  Note: Documentation such as `help cmd.exe` and
                                    "  http://www.microsoft.com/resources/documentation/windows/xp/all/proddocs/en-us/cmd.mspx?mfr=true
                                    "  suggest other special characters that require escaping for command
                                    "  line completion.  But tagbar.vim does not use the command line
                                    "  completion feature of cmd.exe and testing shows that the only special
                                    "  character that needs to be escaped for tagbar.vim is <space> for
                                    "  windows cmd.exe.
                                    let ctags_cmd = a:ctags_bin
                                else
    2              0.000019         let ctags_cmd = shellescape(a:ctags_bin)
    2              0.000003     endif
                            
                                "Add additional arguments to ctags_cmd
    2              0.000011     if type(a:args)==type('')
                                    "When a:args is a string, append the arguments
                                    "Note: In this case, do not attempt to shell escape a:args string.
                                    "This function expects the string to already be escaped properly for
                                    "the shell type. Why not escape? Because it could be ambiguous about
                                    "whether a space is an argument separator or included in the argument.
                                    "Since escaping rules vary from shell to shell, it is better to pass a
                                    "list of arguments to a:args. With a list, each argument is clearly
                                    "separated, so shellescape() can calculate the appropriate escaping
                                    "for each argument for the current &shell.
                                    let ctags_cmd .= ' ' . a:args
                                elseif type(a:args)==type([])
                                    "When a:args is a list, shellescape() each argument and append ctags_cmd
                                    "Note: It's a better practice to shellescape() each argument separately so that
                                    "spaces used as a separator between arguments can be distinguished with
                                    "spaces used inside a single argument.
   22              0.000076         for arg in a:args
   20              0.000153             let ctags_cmd .= ' ' . shellescape(arg)
   20              0.000033         endfor
    2              0.000003     endif
                            
                                "if a filename was specified, add filename as final argument to ctags_cmd.
    2              0.000005     if a:0 == 1
    2              0.000018         let ctags_cmd .= ' ' . shellescape(a:1)
    2              0.000003     endif
                            
    2              0.000010     if exists('+shellslash')
                                    let &shellslash = shellslash_save
                                endif
                            
                                " Needed for cases where 'encoding' is different from the system's
                                " encoding
    2              0.000014     if has('multi_byte')
    2              0.000012         if g:tagbar_systemenc != &encoding
                                        let ctags_cmd = iconv(ctags_cmd, &encoding, g:tagbar_systemenc)
                                    elseif $LANG != ''
    2              0.000072             let ctags_cmd = iconv(ctags_cmd, &encoding, $LANG)
    2              0.000004         endif
    2              0.000003     endif
                            
    2   0.000060   0.000029     call s:debug('Escaped ctags command: ' . ctags_cmd)
                            
    2              0.000008     if ctags_cmd == ''
                                    echoerr 'Tagbar: Encoding conversion failed!' 'Please make sure your system is set up correctly' 'and that Vim is compiled with the "+iconv" feature.'
                                endif
                            
    2              0.000006     return ctags_cmd

FUNCTION  SyntasticMake()
Called 2 times
Total time:   1.130120
 Self time:   0.002186

count  total (s)   self (s)
    2   0.000102   0.000047     call syntastic#log#debug(g:SyntasticDebugTrace, 'SyntasticMake: called with options:', a:options)
                            
                                " save options and locale env variables {{{3
    2              0.000020     let old_shellredir = &shellredir
    2              0.000014     let old_local_errorformat = &l:errorformat
    2              0.000015     let old_errorformat = &errorformat
    2              0.000022     let old_cwd = getcwd()
    2              0.000020     let old_lc_messages = $LC_MESSAGES
    2              0.000014     let old_lc_all = $LC_ALL
                                " }}}3
                            
    2   0.000110   0.000035     call s:bashHack()
                            
    2              0.000014     if has_key(a:options, 'errorformat')
    2              0.000025         let &errorformat = a:options['errorformat']
    2              0.000003     endif
                            
    2              0.000011     if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(a:options['cwd'])
                                endif
                            
                                " set environment variables {{{3
    2              0.000010     let env_save = {}
    2              0.000014     if has_key(a:options, 'env') && len(a:options['env'])
                                    for key in keys(a:options['env'])
                                        if key =~? '\m^[a-z_]\+$'
                                            exec 'let env_save[' . string(key) . '] = $' . key
                                            exec 'let $' . key . ' = ' . string(a:options['env'][key])
                                        endif
                                    endfor
                                endif
    2              0.000023     let $LC_MESSAGES = 'C'
    2              0.000011     let $LC_ALL = ''
                                " }}}3
                            
    2   1.127795   0.000314     let err_lines = split(system(a:options['makeprg']), "\n", 1)
                            
                                " restore environment variables {{{3
    2              0.000051     let $LC_ALL = old_lc_all
    2              0.000023     let $LC_MESSAGES = old_lc_messages
    2              0.000016     if len(env_save)
                                    for key in keys(env_save)
                                        exec 'let $' . key . ' = ' . string(env_save[key])
                                    endfor
                                endif
                                " }}}3
                            
    2   0.000158   0.000066     call syntastic#log#debug(g:SyntasticDebugLoclist, 'checker output:', err_lines)
                            
    2              0.000021     if has_key(a:options, 'Preprocess')
                                    let err_lines = call(a:options['Preprocess'], [err_lines])
                                    call syntastic#log#debug(g:SyntasticDebugLoclist, 'preprocess (external):', err_lines)
                                elseif has_key(a:options, 'preprocess')
                                    let err_lines = call('syntastic#preprocess#' . a:options['preprocess'], [err_lines])
                                    call syntastic#log#debug(g:SyntasticDebugLoclist, 'preprocess:', err_lines)
                                endif
    2              0.000307     lgetexpr err_lines
                            
    2              0.000064     let errors = deepcopy(getloclist(0))
                            
    2              0.000014     if has_key(a:options, 'cwd')
                                    execute 'lcd ' . fnameescape(old_cwd)
                                endif
                            
    2              0.000007     try
    2              0.000082         silent lolder
    1              0.000002     catch /\m^Vim\%((\a\+)\)\=:E380/
                                    " E380: At bottom of quickfix stack
    1              0.000022         call setloclist(0, [], 'r')
    1              0.000008     catch /\m^Vim\%((\a\+)\)\=:E776/
                                    " E776: No location list
                                    " do nothing
                                endtry
                            
                                " restore options {{{3
    2              0.000035     let &errorformat = old_errorformat
    2              0.000016     let &l:errorformat = old_local_errorformat
    2              0.000017     let &shellredir = old_shellredir
                                " }}}3
                            
    2   0.000222   0.000108     if !s:running_windows && (s:uname() =~ "FreeBSD" || s:uname() =~ "OpenBSD")
                                    call syntastic#util#redraw(g:syntastic_full_redraws)
                                endif
                            
    2   0.000095   0.000037     call syntastic#log#debug(g:SyntasticDebugLoclist, 'raw loclist:', errors)
                            
    2   0.000108   0.000049     if syntastic#util#var('exit_checks') && has_key(a:options, 'returns') && index(a:options['returns'], v:shell_error) == -1
                                    throw 'Syntastic: checker error'
                                endif
                            
    2              0.000014     if has_key(a:options, 'defaults')
                                    call s:addToErrors(errors, a:options['defaults'])
                                endif
                            
                                " Add subtype info if present.
    2              0.000011     if has_key(a:options, 'subtype')
                                    call s:addToErrors(errors, { 'subtype': a:options['subtype'] })
                                endif
                            
    2              0.000017     if has_key(a:options, 'Postprocess') && !empty(a:options['Postprocess'])
                                    for rule in a:options['Postprocess']
                                        let errors = call(rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:SyntasticDebugLoclist, 'postprocess (external):', errors)
                                elseif has_key(a:options, 'postprocess') && !empty(a:options['postprocess'])
                                    for rule in a:options['postprocess']
                                        let errors = call('syntastic#postprocess#' . rule, [errors])
                                    endfor
                                    call syntastic#log#debug(g:SyntasticDebugLoclist, 'postprocess:', errors)
                                endif
                            
    2              0.000007     return errors

FUNCTION  airline#statusline()
Called 56 times
Total time:   0.003411
 Self time:   0.003411

count  total (s)   self (s)
   56              0.001628   if has_key(s:contexts, a:winnr)
   56              0.001414     return '%{airline#check_mode('.a:winnr.')}'.s:contexts[a:winnr].line
                              endif
                            
                              " in rare circumstances this happens...see #276
                              return ''

FUNCTION  sy#repo#detect()
Called 2 times
Total time:   1.132458
 Self time:   0.001056

count  total (s)   self (s)
    2              0.000034   let dir = fnamemodify(b:sy.path, ':h')
                            
                              " Simple cache. If there is a registered VCS-controlled file in this
                              " directory already, assume that this file is probably controlled by
                              " the same VCS. Thus we shuffle that VCS to the top of our vcs_list.
    2              0.000060   if has_key(g:sy_cache, dir)
                                let idx = index(s:vcs_list, g:sy_cache[dir])
                                if idx != -1
                                  call remove(s:vcs_list, idx)
                                  call insert(s:vcs_list, g:sy_cache[dir], 0)
                                endif
                              endif
                            
   10              0.000073   for type in s:vcs_list
    8   1.131911   0.000509     let [istype, diff] = sy#repo#get_diff_{type}()
    8              0.000050     if istype
                                  return [ diff, type ]
                                endif
    8              0.000064   endfor
                            
    2              0.000017   return [ '', 'unknown' ]

FUNCTION  syntastic#util#unique()
Called 6 times
Total time:   0.000689
 Self time:   0.000689

count  total (s)   self (s)
    6              0.000051     let seen = {}
    6              0.000031     let uniques = []
   22              0.000073     for e in a:list
   16              0.000094         if !has_key(seen, e)
   16              0.000088             let seen[e] = 1
   16              0.000141             call add(uniques, e)
   16              0.000030         endif
   16              0.000025     endfor
    6              0.000020     return uniques

FUNCTION  <SNR>159_SortTags()
Called 2 times
Total time:   0.001044
 Self time:   0.000259

count  total (s)   self (s)
    2   0.000896   0.000111     call sort(a:tags, a:comparemethod)
                            
   10              0.000025     for tag in a:tags
    8              0.000034         if has_key(tag, 'children')
                                        call s:SortTags(tag.children, a:comparemethod)
                                    endif
    8              0.000012     endfor

FUNCTION  <SNR>93_ignoreFile()
Called 4 times
Total time:   0.000276
 Self time:   0.000276

count  total (s)   self (s)
    4              0.000142     let fname = fnamemodify(a:filename, ':p')
    4              0.000045     for pattern in g:syntastic_ignore_files
                                    if fname =~# pattern
                                        return 1
                                    endif
                                endfor
    4              0.000011     return 0

FUNCTION  <SNR>137_sync_active_winnr()
Called 50 times
Total time:   0.001433
 Self time:   0.001433

count  total (s)   self (s)
   50              0.000873   if exists('#airline') && winnr() != s:active_winnr
                                call airline#update_statusline()
                              endif

FUNCTION  airline#extensions#branch#get_head()
Called 56 times
Total time:   0.019368
 Self time:   0.003651

count  total (s)   self (s)
   56   0.016542   0.000825   let head = airline#extensions#branch#head()
   56              0.000963   let empty_message = get(g:, 'airline#extensions#branch#empty_message', get(g:, 'airline_branch_empty_message', ''))
   56              0.000781   let symbol = get(g:, 'airline#extensions#branch#symbol', g:airline_symbols.branch)
   56              0.000838   return empty(head) ? empty_message : printf('%s%s', empty(symbol) ? '' : symbol.(g:airline_symbols.space), head)

FUNCTION  fugitive#head()
Called 56 times
Total time:   0.000668
 Self time:   0.000668

count  total (s)   self (s)
   56              0.000372   if !exists('b:git_dir')
   56              0.000143     return ''
                              endif
                            
                              return s:repo().head(a:0 ? a:1 : 0)

FUNCTION  288()
Called 2 times
Total time:   0.000364
 Self time:   0.000042

count  total (s)   self (s)
    2   0.000063   0.000019     call syntastic#log#debug(g:SyntasticDebugNotifications, 'autoloclist: refresh')
    2   0.000298   0.000020     call g:SyntasticAutoloclistNotifier.AutoToggle(a:loclist)

FUNCTION  289()
Called 2 times
Total time:   0.000278
 Self time:   0.000101

count  total (s)   self (s)
    2   0.000124   0.000014     call syntastic#log#debug(g:SyntasticDebugNotifications, 'autoloclist: toggle')
    2   0.000027   0.000016     if !a:loclist.isEmpty()
                                    if syntastic#util#var('auto_loc_list') == 1
                                        call a:loclist.show()
                                    endif
                                else
    2   0.000072   0.000016         if syntastic#util#var('auto_loc_list') > 0
                            
                                        "TODO: this will close the loc list window if one was opened by
                                        "something other than syntastic
    2              0.000005             lclose
    2              0.000002         endif
    2              0.000002     endif

FUNCTION  <SNR>159_debug()
Called 64 times
Total time:   0.000953
 Self time:   0.000953

count  total (s)   self (s)
   64              0.000200     if s:debug
                                    execute 'redir >> ' . s:debug_file
                                    silent echon s:gettime() . ': ' . a:msg . "\n"
                                    redir END
                                endif

FUNCTION  <SNR>93_uname()
Called 4 times
Total time:   0.000114
 Self time:   0.000114

count  total (s)   self (s)
    4              0.000037     if !exists('s:uname')
                                    let s:uname = system('uname')
                                    lockvar s:uname
                                endif
    4              0.000017     return s:uname

FUNCTION  syntastic#util#shexpand()
Called 4 times
Total time:   0.000204
 Self time:   0.000074

count  total (s)   self (s)
    4   0.000201   0.000071     return syntastic#util#shescape(expand(a:string))

FUNCTION  airline#extensions#hunks#get_hunks()
Called 56 times
Total time:   0.011049
 Self time:   0.004271

count  total (s)   self (s)
   56              0.000553   if !get(w:, 'airline_active', 0)
                                return ''
                              endif
   56   0.007632   0.000854   let hunks = s:get_hunks()
   56              0.000259   let string = ''
   56              0.000328   if !empty(hunks)
                                for i in [0, 1, 2]
                                  if s:non_zero_only == 0 || hunks[i] > 0
                                    let string .= printf('%s%s ', s:hunk_symbols[i], hunks[i])
                                  endif
                                endfor
                              endif
   56              0.000206   return string

FUNCTION  <SNR>159_ExecuteCtags()
Called 2 times
Total time:   0.053793
 Self time:   0.000624

count  total (s)   self (s)
    2   0.000052   0.000026     call s:debug('Executing ctags command: ' . a:ctags_cmd)
                            
    2              0.000008     if has('unix')
                                    " Reset shell in case it is set to something incompatible like fish
    2              0.000012         let shell_save = &shell
    2              0.000019         set shell=sh
    2              0.000003     endif
                            
    2              0.000009     if exists('+shellslash')
                                    let shellslash_save = &shellslash
                                    set noshellslash
                                endif
                            
    2              0.000020     if &shell =~ 'cmd\.exe'
                                    let shellxquote_save = &shellxquote
                                    set shellxquote=\"
                                    let shellcmdflag_save = &shellcmdflag
                                    set shellcmdflag=/s\ /c
                                endif
                            
    2              0.000004     if s:debug
                                    silent 5verbose let ctags_output = system(a:ctags_cmd)
                                    call s:debug(v:statusmsg)
                                    redraw!
                                else
    2   0.053371   0.000228         let ctags_output = system(a:ctags_cmd)
    2              0.000020     endif
                            
    2              0.000070     if &shell =~ 'cmd\.exe'
                                    let &shellxquote  = shellxquote_save
                                    let &shellcmdflag = shellcmdflag_save
                                endif
                            
    2              0.000017     if exists('+shellslash')
                                    let &shellslash = shellslash_save
                                endif
                            
    2              0.000010     if has('unix')
    2              0.000027         let &shell = shell_save
    2              0.000004     endif
                            
    2              0.000013     return ctags_output

FUNCTION  <SNR>210__searchHeaders()
Called 1 time
Total time:   0.003349
 Self time:   0.003349

count  total (s)   self (s)
    1              0.000007     let includes = ''
    1              0.000005     let files = []
    1              0.000004     let found = []
    1              0.001079     let lines = filter(getline(1, 100), 'v:val =~# ''\m^\s*#\s*include''')
                            
                                " search current buffer
    5              0.000023     for line in lines
    4              0.000078         let file = matchstr(line, '\m"\zs\S\+\ze"')
    4              0.000020         if file != ''
                                        call add(files, file)
                                        continue
                                    endif
                            
   60              0.000186         for handler in s:handlers
   56              0.000620             if line =~# handler["regex"]
                                            let includes .= call(handler["func"], handler["args"])
                                            call add(found, handler["regex"])
                                            break
                                        endif
   56              0.000131         endfor
    4              0.000010     endfor
                            
                                " search included headers
    1              0.000005     for hfile in files
                                    if hfile != ''
                                        let filename = expand('%:p:h') . syntastic#util#Slash() . hfile
                            
                                        try
                                            let lines = readfile(filename, '', 100)
                                        catch /\m^Vim\%((\a\+)\)\=:E484/
                                            continue
                                        endtry
                            
                                        call filter(lines, 'v:val =~# ''\m^\s*#\s*include''')
                            
                                        for handler in s:handlers
                                            if index(found, handler["regex"]) != -1
                                                continue
                                            endif
                            
                                            for line in lines
                                                if line =~# handler["regex"]
                                                    let includes .= call(handler["func"], handler["args"])
                                                    call add(found, handler["regex"])
                                                    break
                                                endif
                                            endfor
                                        endfor
                                    endif
                                endfor
                            
    1              0.000004     return includes

FUNCTION  291()
Called 4 times
Total time:   0.000128
 Self time:   0.000053

count  total (s)   self (s)
    4   0.000123   0.000048     return has('balloon_eval') && syntastic#util#var('enable_balloons')

FUNCTION  292()
Called 2 times
Total time:   0.000209
 Self time:   0.000135

count  total (s)   self (s)
    2              0.000017     let b:syntastic_balloons = {}
    2   0.000101   0.000027     if self.enabled() && !a:loclist.isEmpty()
                                    call syntastic#log#debug(g:SyntasticDebugNotifications, 'balloons: refresh')
                                    let buf = bufnr('')
                                    let issues = filter(a:loclist.copyRaw(), 'v:val["bufnr"] == buf')
                                    if !empty(issues)
                                        for i in issues
                                            if has_key(b:syntastic_balloons, i['lnum'])
                                                let b:syntastic_balloons[i['lnum']] .= "\n" . i['text']
                                            else
                                                let b:syntastic_balloons[i['lnum']] = i['text']
                                            endif
                                        endfor
                                        set beval bexpr=SyntasticBalloonsExprNotifier()
                                    endif
                                endif

FUNCTION  293()
Called 2 times
Total time:   0.000229
 Self time:   0.000167

count  total (s)   self (s)
    2              0.000029     let b:syntastic_balloons = {}
    2              0.000019     if has('balloon_eval')
    2   0.000097   0.000035         call syntastic#log#debug(g:SyntasticDebugNotifications, 'balloons: reset')
    2              0.000069         set nobeval
    2              0.000005     endif

FUNCTION  294()
Called 18 times
Total time:   0.005199
 Self time:   0.005199

count  total (s)   self (s)
   18              0.000673     let newObj = copy(self)
                            
   18              0.000258     let newObj._filetype = a:args['filetype']
   18              0.000206     let newObj._name = a:args['name']
   18              0.000317     let newObj._exec = get(a:args, 'exec', newObj._name)
   18              0.000156     let newObj._sort = 0
                            
   18              0.000196     if has_key(a:args, 'redirect')
    5              0.000178         let [filetype, name] = split(a:args['redirect'], '/')
    5              0.000084         let prefix = 'SyntaxCheckers_' . filetype . '_' . name . '_'
    5              0.000020     else
   13              0.000259         let prefix = 'SyntaxCheckers_' . newObj._filetype . '_' . newObj._name . '_'
   13              0.000049     endif
                            
   18              0.000398     let newObj._locListFunc = function(prefix . 'GetLocList')
                            
   18              0.000324     if exists('*' . prefix . 'IsAvailable')
    3              0.000060         let newObj._isAvailableFunc = function(prefix . 'IsAvailable')
    3              0.000011     else
   15              0.000289         let newObj._isAvailableFunc = function('SyntasticCheckerIsAvailableDefault')
   15              0.000055     endif
                            
   18              0.000313     if exists('*' . prefix . 'GetHighlightRegex')
                                    let newObj._highlightRegexFunc = function(prefix . 'GetHighlightRegex')
                                endif
                            
   18              0.000126     return newObj

FUNCTION  295()
Called 20 times
Total time:   0.000188
 Self time:   0.000188

count  total (s)   self (s)
   20              0.000149     return self._filetype

FUNCTION  296()
Called 20 times
Total time:   0.000189
 Self time:   0.000189

count  total (s)   self (s)
   20              0.000146     return self._name

FUNCTION  297()
Called 2 times
Total time:   0.000148
 Self time:   0.000096

count  total (s)   self (s)
    2   0.000144   0.000092     return expand( exists('b:syntastic_' . self._name . '_exec') ? b:syntastic_{self._name}_exec : syntastic#util#var(self._filetype . '_' . self._name . '_exec', self._exec) )

FUNCTION  299()
Called 2 times
Total time:   1.141266
 Self time:   0.000363

count  total (s)   self (s)
    2              0.000016     let name = self._filetype . '/' . self._name
    2              0.000008     try
    2   1.140357   0.000046         let list = self._locListFunc()
    2   0.000102   0.000051         call syntastic#log#debug(g:SyntasticDebugTrace, 'getLocList: checker ' . name . ' returned ' . v:shell_error)
    2              0.000008     catch /\m\C^Syntastic: checker error$/
                                    let list = []
                                    call syntastic#log#error('checker ' . name . ' returned abnormal status ' . v:shell_error)
                                endtry
    2   0.000121   0.000046     call self._populateHighlightRegexes(list)
    2   0.000084   0.000035     call syntastic#log#debug(g:SyntasticDebugLoclist, name . ' raw:', list)
    2   0.000449   0.000032     call self._quietMessages(list)
    2              0.000012     return list

FUNCTION  <SNR>159_HighlightTag()
Called 2 times
Total time:   0.000571
 Self time:   0.000119

count  total (s)   self (s)
    2              0.000009     let tagline = 0
                            
    2              0.000010     let force = a:0 > 0 ? a:1 : 0
                            
    2              0.000005     if a:0 > 1
                                    let tag = s:GetNearbyTag(1, 0, a:2)
                                else
    2   0.000476   0.000024         let tag = s:GetNearbyTag(1, 0)
    2              0.000003     endif
    2              0.000008     if !empty(tag)
    2              0.000009         let tagline = tag.tline
    2              0.000002     endif
                            
                                " Don't highlight the tag again if it's the same one as last time.
                                " This prevents the Tagbar window from jumping back after scrolling with
                                " the mouse.
    2              0.000010     if !force && tagline == s:last_highlight_tline
    2              0.000004         return
                                else
                                    let s:last_highlight_tline = tagline
                                endif
                            
                                let tagbarwinnr = bufwinnr('__Tagbar__')
                                if tagbarwinnr == -1
                                    return
                                endif
                                let prevwinnr = winnr()
                                call s:goto_win(tagbarwinnr)
                            
                                match none
                            
                                " No tag above cursor position so don't do anything
                                if tagline == 0
                                    call s:goto_win(prevwinnr)
                                    redraw
                                    return
                                endif
                            
                                if g:tagbar_autoshowtag == 1 || a:openfolds
                                    call s:OpenParents(tag)
                                endif
                            
                                " Check whether the tag is inside a closed fold and highlight the parent
                                " instead in that case
                                let tagline = tag.getClosedParentTline()
                            
                                " Parent tag line number is invalid, better don't do anything
                                if tagline <= 0
                                    call s:goto_win(prevwinnr)
                                    redraw
                                    return
                                endif
                            
                                " Go to the line containing the tag
                                execute tagline
                            
                                " Make sure the tag is visible in the window
                                call winline()
                            
                                let foldpat = '[' . s:icon_open . s:icon_closed . ' ]'
                                let pattern = '/^\%' . tagline . 'l\s*' . foldpat . '[-+# ]\zs[^( ]\+\ze/'
                                call s:debug("Highlight pattern: '" . pattern . "'")
                                if hlexists('TagbarHighlight') " Safeguard in case syntax highlighting is disabled
                                    execute 'match TagbarHighlight ' . pattern
                                else
                                    execute 'match Search ' . pattern
                                endif
                            
                            
                                if a:0 <= 1 " no line explicitly given, so assume we were in the file window
                                    call s:goto_win(prevwinnr)
                                endif
                            
                                redraw

FUNCTION  <SNR>93_CacheErrors()
Called 2 times
Total time:   1.219592
 Self time:   0.001379

count  total (s)   self (s)
    2   0.000117   0.000058     call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: ' . (len(a:checker_names) ? join(a:checker_names) : 'default checkers'))
    2   0.005426   0.000046     call s:ClearCache()
    2   0.000333   0.000060     let newLoclist = g:SyntasticLoclist.New([])
                            
    2   0.000437   0.000033     if !s:skipFile()
                                    " debug logging {{{3
    2   0.000107   0.000042         call syntastic#log#debugShowVariables(g:SyntasticDebugTrace, 'aggregate_errors')
    2   0.000100   0.000045         call syntastic#log#debug(g:SyntasticDebugTrace, 'getcwd() = ' . getcwd())
                                    " }}}3
                            
    2   0.000136   0.000055         let filetypes = s:resolveFiletypes()
    2   0.000136   0.000068         let aggregate_errors = syntastic#util#var('aggregate_errors') || len(filetypes) > 1
    2              0.000024         let decorate_errors = aggregate_errors && syntastic#util#var('id_checkers')
    2              0.000021         let sort_aggregated_errors = aggregate_errors && syntastic#util#var('sort_aggregated_errors')
                            
    2              0.000011         let clist = []
    4              0.000021         for type in filetypes
    2   0.069093   0.000067             call extend(clist, s:registry.getCheckers(type, a:checker_names))
    2              0.000007         endfor
                            
    2              0.000008         let names = []
    2              0.000009         let unavailable_checkers = 0
    4              0.000016         for checker in clist
    2   0.000064   0.000043             let cname = checker.getFiletype() . '/' . checker.getName()
    2   0.000586   0.000026             if !checker.isAvailable()
                                            call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: Checker ' . cname . ' is not available')
                                            let unavailable_checkers += 1
                                            continue
                                        endif
                            
    2   0.000072   0.000030             call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: Invoking checker: ' . cname)
                            
    2   1.141707   0.000050             let loclist = checker.getLocList()
                            
    2   0.000082   0.000041             if !loclist.isEmpty()
                                            if decorate_errors
                                                call loclist.decorate(cname)
                                            endif
                                            call add(names, cname)
                                            if checker.getWantSort() && !sort_aggregated_errors
                                                call loclist.sort()
                                                call syntastic#log#debug(g:SyntasticDebugLoclist, 'sorted:', loclist)
                                            endif
                            
                                            let newLoclist = newLoclist.extend(loclist)
                            
                                            if !aggregate_errors
                                                break
                                            endif
                                        endif
    2              0.000004         endfor
                            
                                    " set names {{{3
    2              0.000010         if !empty(names)
                                        if len(syntastic#util#unique(map( copy(names), 'substitute(v:val, "\\m/.*", "", "")' ))) == 1
                                            let type = substitute(names[0], '\m/.*', '', '')
                                            let name = join(map( names, 'substitute(v:val, "\\m.\\{-}/", "", "")' ), ', ')
                                            call newLoclist.setName( name . ' ('. type . ')' )
                                        else
                                            " checkers from mixed types
                                            call newLoclist.setName(join(names, ', '))
                                        endif
                                    endif
                                    " }}}3
                            
                                    " issue warning about no active checkers {{{3
    2              0.000013         if len(clist) == unavailable_checkers
                                        if !empty(a:checker_names)
                                            if len(a:checker_names) == 1
                                                call syntastic#log#warn('checker ' . a:checker_names[0] . ' is not available')
                                            else
                                                call syntastic#log#warn('checkers ' . join(a:checker_names, ', ') . ' are not available')
                                            endif
                                        else
                                            call syntastic#log#debug(g:SyntasticDebugTrace, 'CacheErrors: no checkers available for ' . &filetype)
                                        endif
                                    endif
                                    " }}}3
                            
    2   0.000085   0.000035         call syntastic#log#debug(g:SyntasticDebugLoclist, 'aggregated:', newLoclist)
    2              0.000007         if sort_aggregated_errors
                                        call newLoclist.sort()
                                        call syntastic#log#debug(g:SyntasticDebugLoclist, 'sorted:', newLoclist)
                                    endif
    2              0.000004     endif
                            
    2   0.000460   0.000029     call newLoclist.deploy()

FUNCTION  SyntasticStatuslineFlag()
Called 56 times
Total time:   0.011824
 Self time:   0.001297

count  total (s)   self (s)
   56   0.011755   0.001228     return g:SyntasticLoclist.current().getStatuslineFlag()

FUNCTION  <SNR>159_ExecuteCtagsOnFile()
Called 2 times
Total time:   0.055900
 Self time:   0.000817

count  total (s)   self (s)
    2   0.000061   0.000029     call s:debug('ExecuteCtagsOnFile called [' . a:fname . ']')
                            
    2              0.000018     if has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type('')
                                    " if ctagsargs is a string, prepend and append space separators
                                    let ctags_args = ' ' . a:typeinfo.ctagsargs . ' '
                                elseif has_key(a:typeinfo, 'ctagsargs') && type(a:typeinfo.ctagsargs) == type([])
                                    let ctags_args = a:typeinfo.ctagsargs
                                " otherwise ctagsargs is not defined or not defined as a valid type
                                else
                                    "Prefer constructing ctags_args as a list rather than a string
                                    "See s:EscapeCtagsCmd() - It's a best practice to shellescape()
                                    "each arg separately because in special cases where space is
                                    "intended to be in an argument, spaces in a single ctag_args
                                    "string would be ambiguous. Is the space an argument separator
                                    "or to be included in the argument
    2              0.000020         let ctags_args  = [ '-f', '-', '--format=2', '--excmd=pattern', '--fields=nksSa', '--extra=', '--sort=no', '--append=no' ]
                            
                                    " Include extra type definitions
    2              0.000011         if has_key(a:typeinfo, 'deffile')
                                        let ctags_args += ['--options=' . expand(a:typeinfo.deffile)]
                                    endif
                            
    2              0.000011         let ctags_type = a:typeinfo.ctagstype
                            
    2              0.000007         let ctags_kinds = ''
   26              0.000049         for kind in a:typeinfo.kinds
   24              0.000106             let ctags_kinds .= kind.short
   24              0.000039         endfor
                            
    2              0.000015         let ctags_args += ['--language-force=' . ctags_type]
    2              0.000016         let ctags_args += ['--' . ctags_type . '-kinds=' . ctags_kinds]
    2              0.000004     endif
                            
    2              0.000010     if has_key(a:typeinfo, 'ctagsbin')
                                    " reset 'wildignore' temporarily in case *.exe is included in it
                                    let wildignore_save = &wildignore
                                    set wildignore&
                                    let ctags_bin = expand(a:typeinfo.ctagsbin)
                                    let &wildignore = wildignore_save
                                else
    2              0.000010         let ctags_bin = g:tagbar_ctags_bin
    2              0.000002     endif
                            
    2   0.001262   0.000049     let ctags_cmd = s:EscapeCtagsCmd(ctags_bin, ctags_args, a:fname)
    2              0.000007     if ctags_cmd == ''
                                    return ''
                                endif
                            
    2   0.053850   0.000057     let ctags_output = s:ExecuteCtags(ctags_cmd)
                            
    2              0.000046     if v:shell_error || ctags_output =~ 'Warning: cannot open source file'
                                    " Only display an error message if the Tagbar window is open and we
                                    " haven't seen the error before.
                                    if bufwinnr("__Tagbar__") != -1 && (!s:known_files.has(a:realfname) || !empty(s:known_files.get(a:realfname)))
                                        echoerr 'Tagbar: Could not execute ctags for ' . a:fname . '!'
                                        echomsg 'Executed command: "' . ctags_cmd . '"'
                                        if !empty(ctags_output)
                                            call s:debug('Command output:')
                                            call s:debug(ctags_output)
                                            echomsg 'Command output:'
                                            for line in split(ctags_output, '\n')
                                                echomsg line
                                            endfor
                                        endif
                                    endif
                                    return -1
                                endif
                            
    2   0.000087   0.000042     call s:debug('Ctags executed successfully')
    2              0.000013     return ctags_output

FUNCTION  <SNR>93_bashHack()
Called 2 times
Total time:   0.000075
 Self time:   0.000075

count  total (s)   self (s)
    2              0.000015     if g:syntastic_bash_hack
                                    if !exists('s:shell_is_bash')
                                        let s:shell_is_bash = !s:running_windows && (s:uname() !~# "FreeBSD") && (s:uname() !~# "OpenBSD") && &shell =~# '\m\<bash$'
                                    endif
                            
                                    if s:shell_is_bash
                                        let &shellredir = '&>'
                                    endif
                                endif

FUNCTION  airline#util#prepend()
Called 56 times
Total time:   0.001513
 Self time:   0.001513

count  total (s)   self (s)
   56              0.000369   if a:minwidth > 0 && winwidth(0) < a:minwidth
                                return ''
                              endif
   56              0.000783   return empty(a:text) ? '' : a:text.s:spc.g:airline_right_alt_sep.s:spc

FUNCTION  <SNR>159_AutoUpdate()
Called 2 times
Total time:   0.071083
 Self time:   0.001072

count  total (s)   self (s)
    2   0.000088   0.000049     call s:debug('AutoUpdate called [' . a:fname . ']')
                            
                                " This file is being loaded due to a quickfix command like vimgrep, so
                                " don't process it
    2              0.000011     if exists('s:tagbar_qf_active')
                                    return
                                elseif exists('s:window_opening')
                                    " This can happen if another plugin causes the active window to change
                                    " with an autocmd during the initial Tagbar window creation. In that
                                    " case InitWindow() hasn't had a chance to run yet and things can
                                    " break. MiniBufExplorer does this, for example. Completely disabling
                                    " autocmds at that point is also not ideal since for example
                                    " statusline plugins won't be able to update.
                                    call s:debug('Still opening window, stopping processing')
                                    return
                                endif
                            
                                " Get the filetype of the file we're about to process
    2              0.000051     let bufnr = bufnr(a:fname)
    2              0.000016     let ftype = getbufvar(bufnr, '&filetype')
                            
                                " Don't do anything if we're in the tagbar window
    2              0.000011     if ftype == 'tagbar'
                                    call s:debug('In Tagbar window, stopping processing')
                                    return
                                endif
                            
                                " Only consider the main filetype in cases like 'python.django'
    2              0.000054     let sftype = get(split(ftype, '\.'), 0, '')
    2   0.000061   0.000029     call s:debug("Vim filetype: '" . ftype . "', " . "sanitized filetype: '" . sftype . "'")
                            
                                " Don't do anything if the file isn't supported
    2   0.000341   0.000043     if !s:IsValidFile(a:fname, sftype)
                                    call s:debug('Not a valid file, stopping processing')
                                    let s:nearby_disabled = 1
                                    return
                                endif
                            
    2              0.000010     let updated = 0
                            
                                " Process the file if it's unknown or the information is outdated.
                                " Testing the mtime of the file is necessary in case it got changed
                                " outside of Vim, for example by checking out a different version from a
                                " VCS.
    2   0.000082   0.000057     if s:known_files.has(a:fname)
    2   0.000042   0.000024         let curfile = s:known_files.get(a:fname)
                                    " if a:force || getbufvar(curfile.bufnr, '&modified') ||
    2              0.000016         if a:force || empty(curfile) || (filereadable(a:fname) && getftime(a:fname) > curfile.mtime)
    2   0.000055   0.000026             call s:debug('File data outdated, updating [' . a:fname . ']')
    2   0.068971   0.000072             call s:ProcessFile(a:fname, sftype)
    2              0.000011             let updated = 1
    2              0.000004         else
                                        call s:debug('File data seems up to date [' . a:fname . ']')
                                    endif
    2              0.000007     elseif !s:known_files.has(a:fname)
                                    call s:debug('New file, processing [' . a:fname . ']')
                                    call s:ProcessFile(a:fname, sftype)
                                    let updated = 1
                                endif
                            
    2   0.000051   0.000028     let fileinfo = s:known_files.get(a:fname)
                            
                                " If we don't have an entry for the file by now something must have gone
                                " wrong, so don't change the tagbar content
    2              0.000009     if empty(fileinfo)
                                    call s:debug('fileinfo empty after processing [' . a:fname . ']')
                                    return
                                endif
                            
                                " Display the tagbar content if the tags have been updated or a different
                                " file is being displayed
    2              0.000163     if bufwinnr('__Tagbar__') != -1 && !s:paused && (s:new_window || updated || (!empty(s:known_files.getCurrent(0)) && a:fname != s:known_files.getCurrent(0).fpath))
                                    call s:RenderContent(fileinfo)
                                endif
                            
                                " Call setCurrent after rendering so RenderContent can check whether the
                                " same file is being redisplayed
    2              0.000009     if !empty(fileinfo)
    2   0.000059   0.000028         call s:debug('Setting current file [' . a:fname . ']')
    2   0.000038   0.000023         call s:known_files.setCurrent(fileinfo)
    2              0.000015         let s:nearby_disabled = 0
    2              0.000004     endif
                            
    2   0.000605   0.000034     call s:HighlightTag(0)
    2   0.000055   0.000024     call s:debug('AutoUpdate finished successfully')

FUNCTIONS SORTED ON TOTAL TIME
count  total (s)   self (s)  function
    2   1.227680   0.000222  <SNR>93_BufWritePostHook()
    2   1.227357   0.000776  <SNR>93_UpdateErrors()
    2   1.219592   0.001379  <SNR>93_CacheErrors()
    2   1.141657   0.000073  300()
    2   1.141266   0.000363  299()
    2   1.140311   0.001067  SyntaxCheckers_cpp_gcc_GetLocList()
    2   1.137014   0.000349  syntastic#c#GetLocList()
    2   1.133032   0.000574  sy#start()
    2   1.132458   0.001056  sy#repo#detect()
    2   1.130120   0.002186  SyntasticMake()
    2   0.541683   0.000572  sy#repo#get_diff_bzr()
    2   0.308518   0.000565  sy#repo#get_diff_hg()
    2   0.226279   0.000574  sy#repo#get_diff_svn()
    2   0.071083   0.001072  <SNR>159_AutoUpdate()
    2   0.069026   0.000283  361()
    2   0.068899   0.004322  <SNR>159_ProcessFile()
    2   0.068492   0.007153  368()
    2   0.055900   0.000817  <SNR>159_ExecuteCtagsOnFile()
    2   0.054922   0.000251  sy#repo#get_diff_git()
    2   0.054533   0.000774  sy#util#run_in_dir()

FUNCTIONS SORTED ON SELF TIME
count  total (s)   self (s)  function
   56              0.023828  <SNR>67_generate_names()
   56   0.015717   0.013792  airline#extensions#branch#head()
   56              0.012542  airline#check_mode()
   52              0.012277  <SNR>120_Highlight_Matching_Pair()
   56              0.008888  330()
   56   0.032318   0.008490  bufferline#get_echo_string()
   56   0.008723   0.007419  airline#extensions#whitespace#check()
  448              0.007300  airline#util#wrap()
    2   0.068492   0.007153  368()
  168              0.006041  airline#util#append()
   18              0.005199  294()
    4              0.004422  319()
    2   0.068899   0.004322  <SNR>159_ProcessFile()
   56   0.011049   0.004271  airline#extensions#hunks#get_hunks()
    8   0.005452   0.004203  <SNR>159_ParseTagline()
   56   0.019368   0.003651  airline#extensions#branch#get_head()
   56              0.003550  airline#parts#ffenc()
   56              0.003411  airline#statusline()
   56   0.006778   0.003398  <SNR>142_get_hunks()
    1              0.003349  <SNR>210__searchHeaders()

